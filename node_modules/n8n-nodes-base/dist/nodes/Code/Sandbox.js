"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSandboxContext = exports.Sandbox = void 0;
const n8n_core_1 = require("n8n-core");
const vm2_1 = require("vm2");
const ValidationError_1 = require("./ValidationError");
const ExecutionError_1 = require("./ExecutionError");
const utils_1 = require("./utils");
class Sandbox extends vm2_1.NodeVM {
    constructor(context, workflowMode, nodeMode) {
        super(Sandbox.getSandboxOptions(context, workflowMode));
        this.nodeMode = nodeMode;
        this.jsCode = '';
        this.itemIndex = undefined;
    }
    static getSandboxOptions(context, workflowMode) {
        const { NODE_FUNCTION_ALLOW_BUILTIN: builtIn, NODE_FUNCTION_ALLOW_EXTERNAL: external } = process.env;
        return {
            console: workflowMode === 'manual' ? 'redirect' : 'inherit',
            sandbox: context,
            require: {
                builtin: builtIn ? builtIn.split(',') : [],
                external: external ? { modules: external.split(','), transitive: false } : false,
            },
        };
    }
    async runCode(jsCode, itemIndex) {
        this.jsCode = jsCode;
        this.itemIndex = itemIndex;
        return this.nodeMode === 'runOnceForAllItems' ? this.runCodeAllItems() : this.runCodeEachItem();
    }
    async runCodeAllItems() {
        var _a;
        const script = `module.exports = async function() {${this.jsCode}\n}()`;
        const match = script.match(/(?<disallowedSyntax>\)\.item(?!Matching)|\$input\.item(?!Matching)|\$json|\$binary|\$itemIndex)/);
        if ((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.disallowedSyntax) {
            const { disallowedSyntax } = match.groups;
            const lineNumber = this.jsCode.split('\n').findIndex((line) => {
                return line.includes(disallowedSyntax) && !line.startsWith('//') && !line.startsWith('*');
            }) + 1;
            const disallowedSyntaxFound = lineNumber !== 0;
            if (disallowedSyntaxFound) {
                throw new ValidationError_1.ValidationError({
                    message: `Can't use ${disallowedSyntax} here`,
                    description: "This is only available in 'Run Once for Each Item' mode",
                    itemIndex: this.itemIndex,
                    lineNumber,
                });
            }
        }
        let executionResult;
        try {
            executionResult = await this.run(script, __dirname);
        }
        catch (error) {
            if (error.message === 'items is not defined' && !/(let|const|var) items =/.test(script)) {
                const quoted = error.message.replace('items', '`items`');
                error.message = quoted + '. Did you mean `$input.all()`?';
            }
            throw new ExecutionError_1.ExecutionError(error);
        }
        if (executionResult === null)
            return [];
        if (executionResult === undefined || typeof executionResult !== 'object') {
            throw new ValidationError_1.ValidationError({
                message: "Code doesn't return items properly",
                description: 'Please return an array of objects, one for each item you would like to output',
                itemIndex: this.itemIndex,
            });
        }
        if (Array.isArray(executionResult)) {
            for (const item of executionResult) {
                if (item.json !== undefined && !(0, utils_1.isObject)(item.json)) {
                    throw new ValidationError_1.ValidationError({
                        message: "A 'json' property isn't an object",
                        description: "In the returned data, every key named 'json' must point to an object",
                        itemIndex: this.itemIndex,
                    });
                }
                if (executionResult.some((item) => Object.keys(item).find((key) => utils_1.SUPPORTED_ITEM_KEYS.has(key)))) {
                    Object.keys(item).forEach((key) => {
                        if (utils_1.SUPPORTED_ITEM_KEYS.has(key))
                            return;
                        throw new ValidationError_1.ValidationError({
                            message: `Unknown top-level item key: ${key}`,
                            description: 'Access the properties of an item under `.json`, e.g. `item.json`',
                            itemIndex: this.itemIndex,
                        });
                    });
                }
                if (item.binary !== undefined && !(0, utils_1.isObject)(item.binary)) {
                    throw new ValidationError_1.ValidationError({
                        message: "A 'binary' property isn't an object",
                        description: "In the returned data, every key named 'binary’ must point to an object.",
                        itemIndex: this.itemIndex,
                    });
                }
            }
        }
        else {
            if (executionResult.json !== undefined && !(0, utils_1.isObject)(executionResult.json)) {
                throw new ValidationError_1.ValidationError({
                    message: "A 'json' property isn't an object",
                    description: "In the returned data, every key named 'json' must point to an object",
                    itemIndex: this.itemIndex,
                });
            }
            if (executionResult.binary !== undefined && !(0, utils_1.isObject)(executionResult.binary)) {
                throw new ValidationError_1.ValidationError({
                    message: "A 'binary' property isn't an object",
                    description: "In the returned data, every key named 'binary’ must point to an object.",
                    itemIndex: this.itemIndex,
                });
            }
        }
        return (0, n8n_core_1.normalizeItems)(executionResult);
    }
    async runCodeEachItem() {
        var _a;
        const script = `module.exports = async function() {${this.jsCode}\n}()`;
        const match = this.jsCode.match(/\$input\.(?<disallowedMethod>first|last|all|itemMatching)/);
        if ((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.disallowedMethod) {
            const { disallowedMethod } = match.groups;
            const lineNumber = this.jsCode.split('\n').findIndex((line) => {
                return line.includes(disallowedMethod) && !line.startsWith('//') && !line.startsWith('*');
            }) + 1;
            const disallowedMethodFound = lineNumber !== 0;
            if (disallowedMethodFound) {
                throw new ValidationError_1.ValidationError({
                    message: `Can't use .${disallowedMethod}() here`,
                    description: "This is only available in 'Run Once for All Items' mode",
                    itemIndex: this.itemIndex,
                    lineNumber,
                });
            }
        }
        let executionResult;
        try {
            executionResult = await this.run(script, __dirname);
        }
        catch (error) {
            if (error.message === 'item is not defined' && !/(let|const|var) item =/.test(script)) {
                const quoted = error.message.replace('item', '`item`');
                error.message = quoted + '. Did you mean `$input.item.json`?';
            }
            throw new ExecutionError_1.ExecutionError(error, this.itemIndex);
        }
        if (executionResult === null)
            return;
        if (executionResult === undefined || typeof executionResult !== 'object') {
            throw new ValidationError_1.ValidationError({
                message: "Code doesn't return an object",
                description: `Please return an object representing the output item. ('${executionResult}' was returned instead.)`,
                itemIndex: this.itemIndex,
            });
        }
        if (executionResult.json !== undefined && !(0, utils_1.isObject)(executionResult.json)) {
            throw new ValidationError_1.ValidationError({
                message: "A 'json' property isn't an object",
                description: "In the returned data, every key named 'json' must point to an object",
                itemIndex: this.itemIndex,
            });
        }
        if (executionResult.binary !== undefined && !(0, utils_1.isObject)(executionResult.binary)) {
            throw new ValidationError_1.ValidationError({
                message: "A 'binary' property isn't an object",
                description: "In the returned data, every key named 'binary’ must point to an object.",
                itemIndex: this.itemIndex,
            });
        }
        Object.keys(executionResult).forEach((key) => {
            if (utils_1.SUPPORTED_ITEM_KEYS.has(key))
                return;
            throw new ValidationError_1.ValidationError({
                message: `Unknown top-level item key: ${key}`,
                description: 'Access the properties of an item under `.json`, e.g. `item.json`',
                itemIndex: this.itemIndex,
            });
        });
        if (Array.isArray(executionResult)) {
            const firstSentence = executionResult.length > 0
                ? `An array of ${typeof executionResult[0]}s was returned.`
                : 'An empty array was returned.';
            throw new ValidationError_1.ValidationError({
                message: "Code doesn't return a single object",
                description: `${firstSentence} If you need to output multiple items, please use the 'Run Once for All Items' mode instead`,
                itemIndex: this.itemIndex,
            });
        }
        return executionResult.json ? executionResult : { json: executionResult };
    }
}
exports.Sandbox = Sandbox;
function getSandboxContext(index) {
    const sandboxContext = {
        $getNodeParameter: this.getNodeParameter,
        $getWorkflowStaticData: this.getWorkflowStaticData,
        helpers: this.helpers,
        $item: this.getWorkflowDataProxy,
    };
    Object.assign(sandboxContext, sandboxContext.$item(index !== null && index !== void 0 ? index : 0));
    return sandboxContext;
}
exports.getSandboxContext = getSandboxContext;
//# sourceMappingURL=Sandbox.js.map