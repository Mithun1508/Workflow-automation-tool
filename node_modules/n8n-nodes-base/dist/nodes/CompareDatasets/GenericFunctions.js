"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkInput = exports.checkMatchFieldsInput = exports.findMatches = void 0;
const lodash_1 = require("lodash");
function compareItems(item1, item2, fieldsToMatch, resolve) {
    const keys = {};
    fieldsToMatch.forEach((field) => {
        keys[field.field1] = item1.json[field.field1];
    });
    const keys1 = Object.keys(item1.json);
    const keys2 = Object.keys(item2.json);
    const intersectionKeys = (0, lodash_1.intersection)(keys1, keys2);
    const same = intersectionKeys.reduce((acc, key) => {
        if ((0, lodash_1.isEqual)(item1.json[key], item2.json[key])) {
            acc[key] = item1.json[key];
        }
        return acc;
    }, {});
    const sameKeys = Object.keys(same);
    const allUniqueKeys = (0, lodash_1.union)(keys1, keys2);
    const differentKeys = (0, lodash_1.difference)(allUniqueKeys, sameKeys);
    const different = {};
    differentKeys.forEach((key) => {
        switch (resolve) {
            case 'preferInput1':
                different[key] = item1.json[key] || null;
                break;
            case 'preferInput2':
                different[key] = item2.json[key] || null;
                break;
            default:
                const input1 = item1.json[key] || null;
                const input2 = item2.json[key] || null;
                different[key] = { input1, input2 };
        }
    });
    return { json: { keys, same, different } };
}
function combineItems(item1, item2, prefer, except, disableDotNotation) {
    let exceptFields;
    const [entry, match] = prefer === 'input1' ? [item1, item2] : [item2, item1];
    if (except && Array.isArray(except) && except.length) {
        exceptFields = except;
    }
    else {
        exceptFields = except ? except.split(',').map((field) => field.trim()) : [];
    }
    exceptFields.forEach((field) => {
        entry.json[field] = match.json[field];
        if (disableDotNotation) {
            entry.json[field] = match.json[field];
        }
        else {
            const value = (0, lodash_1.get)(match.json, field) || null;
            (0, lodash_1.set)(entry, `json.${field}`, value);
        }
    });
    return entry;
}
function findAllMatches(data, lookup, disableDotNotation) {
    return data.reduce((acc, entry2, i) => {
        if (entry2 === undefined)
            return acc;
        for (const key of Object.keys(lookup)) {
            const excpectedValue = lookup[key];
            let entry2FieldValue;
            if (disableDotNotation) {
                entry2FieldValue = entry2.json[key];
            }
            else {
                entry2FieldValue = (0, lodash_1.get)(entry2.json, key);
            }
            if (!(0, lodash_1.isEqual)(excpectedValue, entry2FieldValue)) {
                return acc;
            }
        }
        return acc.concat({
            entry: entry2,
            index: i,
        });
    }, []);
}
function findFirstMatch(data, lookup, disableDotNotation) {
    const index = data.findIndex((entry2) => {
        if (entry2 === undefined)
            return false;
        for (const key of Object.keys(lookup)) {
            const excpectedValue = lookup[key];
            let entry2FieldValue;
            if (disableDotNotation) {
                entry2FieldValue = entry2.json[key];
            }
            else {
                entry2FieldValue = (0, lodash_1.get)(entry2.json, key);
            }
            if (!(0, lodash_1.isEqual)(excpectedValue, entry2FieldValue)) {
                return false;
            }
        }
        return true;
    });
    if (index === -1)
        return [];
    return [{ entry: data[index], index }];
}
function findMatches(input1, input2, fieldsToMatch, options) {
    const data1 = [...input1];
    const data2 = [...input2];
    const disableDotNotation = options.disableDotNotation || false;
    const multipleMatches = options.multipleMatches || 'first';
    const filteredData = {
        matched: [],
        unmatched1: [],
        unmatched2: [],
    };
    const matchedInInput2 = new Set();
    matchesLoop: for (const entry of data1) {
        const lookup = {};
        fieldsToMatch.forEach((matchCase) => {
            let valueToCompare;
            if (disableDotNotation) {
                valueToCompare = entry.json[matchCase.field1];
            }
            else {
                valueToCompare = (0, lodash_1.get)(entry.json, matchCase.field1);
            }
            lookup[matchCase.field2] = valueToCompare;
        });
        for (const fieldValue of Object.values(lookup)) {
            if (fieldValue === undefined) {
                filteredData.unmatched1.push(entry);
                continue matchesLoop;
            }
        }
        const foundedMatches = multipleMatches === 'all'
            ? findAllMatches(data2, lookup, disableDotNotation)
            : findFirstMatch(data2, lookup, disableDotNotation);
        const matches = foundedMatches.map((match) => match.entry);
        foundedMatches.map((match) => matchedInInput2.add(match.index));
        if (matches.length) {
            filteredData.matched.push({ entry, matches });
        }
        else {
            filteredData.unmatched1.push(entry);
        }
    }
    data2.forEach((entry, i) => {
        if (!matchedInInput2.has(i)) {
            filteredData.unmatched2.push(entry);
        }
    });
    const same = [];
    const different = [];
    filteredData.matched.forEach((entryMatches) => {
        let entryCopy;
        entryMatches.matches.forEach((match) => {
            if ((0, lodash_1.isEqual)(entryMatches.entry.json, match.json)) {
                if (!entryCopy)
                    entryCopy = match;
            }
            else {
                switch (options.resolve) {
                    case 'preferInput1':
                        different.push(entryMatches.entry);
                        break;
                    case 'preferInput2':
                        different.push(match);
                        break;
                    case 'mix':
                        different.push(combineItems(entryMatches.entry, match, options.preferWhenMix, options.exceptWhenMix, disableDotNotation));
                        break;
                    default:
                        different.push(compareItems(entryMatches.entry, match, fieldsToMatch, options.resolve));
                }
            }
        });
        if (!(0, lodash_1.isEmpty)(entryCopy)) {
            same.push(entryCopy);
        }
    });
    return [filteredData.unmatched1, same, different, filteredData.unmatched2];
}
exports.findMatches = findMatches;
function checkMatchFieldsInput(data) {
    if (data.length === 1 && data[0].field1 === '' && data[0].field2 === '') {
        throw new Error('You need to define at least one pair of fields in "Fields to Match" to match on');
    }
    for (const [index, pair] of data.entries()) {
        if (pair.field1 === '' || pair.field2 === '') {
            throw new Error(`You need to define both fields in "Fields to Match" for pair ${index + 1},
				 field 1 = '${pair.field1}'
				 field 2 = '${pair.field2}'`);
        }
    }
    return data;
}
exports.checkMatchFieldsInput = checkMatchFieldsInput;
function checkInput(input, fields, disableDotNotation, inputLabel) {
    for (const field of fields) {
        const isPresent = (input || []).some((entry) => {
            if (disableDotNotation) {
                return entry.json.hasOwnProperty(field);
            }
            return (0, lodash_1.get)(entry.json, field, undefined) !== undefined;
        });
        if (!isPresent) {
            throw new Error(`Field '${field}' is not present in any of items in '${inputLabel}'`);
        }
    }
    return input;
}
exports.checkInput = checkInput;
//# sourceMappingURL=GenericFunctions.js.map