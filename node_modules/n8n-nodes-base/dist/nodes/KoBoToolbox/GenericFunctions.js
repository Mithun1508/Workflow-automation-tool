"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadForms = exports.downloadAttachments = exports.formatSubmission = exports.parseStringList = exports.koBoToolboxApiRequest = void 0;
const lodash_1 = __importDefault(require("lodash"));
async function koBoToolboxApiRequest(option = {}) {
    const credentials = await this.getCredentials('koBoToolboxApi');
    const returnAll = !!option.returnAll;
    if (returnAll) {
        lodash_1.default.set(option, 'qs.limit', 3000);
        delete option.returnAll;
    }
    const options = {
        url: '',
        headers: {
            Accept: 'application/json',
        },
        json: true,
    };
    if (Object.keys(option)) {
        Object.assign(options, option);
    }
    if (options.url && !/^http(s)?:/.test(options.url)) {
        options.url = credentials.URL + options.url;
    }
    let results = null;
    let keepLooking = true;
    while (keepLooking) {
        const response = await this.helpers.httpRequestWithAuthentication.call(this, 'koBoToolboxApi', options);
        results = response.results ? lodash_1.default.concat(results || [], response.results) : response;
        if (returnAll && response.next) {
            options.url = response.next;
        }
        else {
            keepLooking = false;
        }
    }
    return results;
}
exports.koBoToolboxApiRequest = koBoToolboxApiRequest;
function parseGeoPoint(geoPoint) {
    const coordinates = lodash_1.default.split(geoPoint, ' ');
    if (coordinates.length >= 2 &&
        lodash_1.default.every(coordinates, (coord) => coord && /^-?\d+(?:\.\d+)?$/.test(lodash_1.default.toString(coord)))) {
        return [lodash_1.default.toNumber(coordinates[1]), lodash_1.default.toNumber(coordinates[0])];
    }
    return null;
}
function parseStringList(value) {
    return lodash_1.default.split(lodash_1.default.toString(value), /[\s,]+/);
}
exports.parseStringList = parseStringList;
const matchWildcard = (value, pattern) => {
    const regex = new RegExp(`^${lodash_1.default.escapeRegExp(pattern).replace('\\*', '.*')}$`);
    return regex.test(value);
};
const formatValue = (value, format) => {
    if (lodash_1.default.isString(value)) {
        value = lodash_1.default.toString(value);
        const geoPoint = parseGeoPoint(value);
        if (geoPoint) {
            return {
                type: 'Point',
                coordinates: geoPoint,
            };
        }
        const points = value.split(';');
        if (points.length >= 2 && /^[-\d\.\s;]+$/.test(value)) {
            const coordinates = lodash_1.default.compact(points.map(parseGeoPoint));
            if (coordinates.length === points.length) {
                if (lodash_1.default.first(points) === lodash_1.default.last(points)) {
                    return {
                        type: 'Polygon',
                        coordinates: [coordinates],
                    };
                }
                return { type: 'LineString', coordinates };
            }
        }
        if ('number' === format) {
            return lodash_1.default.toNumber(value);
        }
        if ('multiSelect' === format) {
            return lodash_1.default.split(lodash_1.default.toString(value), ' ');
        }
    }
    return value;
};
function formatSubmission(submission, selectMasks = [], numberMasks = []) {
    const response = {};
    for (const key of Object.keys(submission)) {
        let value = lodash_1.default.clone(submission[key]);
        const sanitizedKey = key
            .split('/')
            .map((k) => lodash_1.default.trim(k, ' _'))
            .join('.');
        const leafKey = sanitizedKey.split('.').pop() || '';
        let format = 'string';
        if (lodash_1.default.some(numberMasks, (mask) => matchWildcard(leafKey, mask))) {
            format = 'number';
        }
        if (lodash_1.default.some(selectMasks, (mask) => matchWildcard(leafKey, mask))) {
            format = 'multiSelect';
        }
        value = formatValue(value, format);
        lodash_1.default.set(response, sanitizedKey, value);
    }
    if (lodash_1.default.isArray(response.geolocation) &&
        response.geolocation.length === 2 &&
        response.geolocation[0] &&
        response.geolocation[1]) {
        response.geolocation = {
            type: 'Point',
            coordinates: [response.geolocation[1], response.geolocation[0]],
        };
    }
    return response;
}
exports.formatSubmission = formatSubmission;
async function downloadAttachments(submission, options) {
    const binaryItem = {
        json: {
            ...submission,
        },
        binary: {},
    };
    const credentials = await this.getCredentials('koBoToolboxApi');
    const attachmentList = (submission['_attachments'] || submission['attachments']);
    if (attachmentList && attachmentList.length) {
        for (const [index, attachment] of attachmentList.entries()) {
            const fileName = attachment.filename;
            const sanitizedFileName = lodash_1.default.toString(fileName).replace(/_[^_]+(?=\.\w+)/, '');
            let relatedQuestion = null;
            if ('question' === options.binaryNamingScheme) {
                for (const question of Object.keys(submission)) {
                    const sanitizedQuestionValue = lodash_1.default.toString(submission[question]).replace(/\s/g, '_');
                    if (sanitizedFileName === sanitizedQuestionValue) {
                        relatedQuestion = question;
                        break;
                    }
                }
            }
            let response = null;
            const attachmentUrl = attachment[options.version] || attachment.download_url;
            let final = false, redir = 0;
            const axiosOptions = {
                url: attachmentUrl,
                method: 'GET',
                headers: {
                    Authorization: `Token ${credentials.token}`,
                },
                ignoreHttpStatusErrors: true,
                returnFullResponse: true,
                disableFollowRedirect: true,
                encoding: 'arraybuffer',
            };
            while (!final && redir < 5) {
                response = await this.helpers.httpRequest(axiosOptions);
                if (response && response.headers.location) {
                    axiosOptions.url = response.headers.location;
                    redir++;
                }
                else {
                    final = true;
                }
            }
            if (response && response.body) {
                let binaryName;
                if ('question' === options.binaryNamingScheme && relatedQuestion) {
                    binaryName = relatedQuestion;
                }
                else {
                    binaryName = `${options.dataPropertyAttachmentsPrefixName || 'attachment_'}${index}`;
                }
                binaryItem.binary[binaryName] = await this.helpers.prepareBinaryData(response.body, fileName);
            }
        }
    }
    else {
        delete binaryItem.binary;
    }
    return binaryItem;
}
exports.downloadAttachments = downloadAttachments;
async function loadForms() {
    const responseData = await koBoToolboxApiRequest.call(this, {
        url: '/api/v2/assets/',
        qs: {
            q: 'asset_type:survey',
            ordering: 'name',
        },
        scroll: true,
    });
    return (responseData === null || responseData === void 0 ? void 0 : responseData.map((survey) => ({ name: survey.name, value: survey.uid }))) || [];
}
exports.loadForms = loadForms;
//# sourceMappingURL=GenericFunctions.js.map