"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addSourceField = exports.checkInput = exports.checkMatchFieldsInput = exports.selectMergeMethod = exports.mergeMatched = exports.findMatches = exports.addSuffixToEntriesKeys = void 0;
const lodash_1 = require("lodash");
function addSuffixToEntriesKeys(data, suffix) {
    return data.map((entry) => {
        const json = {};
        Object.keys(entry.json).forEach((key) => {
            json[`${key}_${suffix}`] = entry.json[key];
        });
        return { ...entry, json };
    });
}
exports.addSuffixToEntriesKeys = addSuffixToEntriesKeys;
function findAllMatches(data, lookup, disableDotNotation) {
    return data.reduce((acc, entry2, i) => {
        if (entry2 === undefined)
            return acc;
        for (const key of Object.keys(lookup)) {
            const excpectedValue = lookup[key];
            let entry2FieldValue;
            if (disableDotNotation) {
                entry2FieldValue = entry2.json[key];
            }
            else {
                entry2FieldValue = (0, lodash_1.get)(entry2.json, key);
            }
            if (!(0, lodash_1.isEqual)(excpectedValue, entry2FieldValue)) {
                return acc;
            }
        }
        return acc.concat({
            entry: entry2,
            index: i,
        });
    }, []);
}
function findFirstMatch(data, lookup, disableDotNotation) {
    const index = data.findIndex((entry2) => {
        if (entry2 === undefined)
            return false;
        for (const key of Object.keys(lookup)) {
            const excpectedValue = lookup[key];
            let entry2FieldValue;
            if (disableDotNotation) {
                entry2FieldValue = entry2.json[key];
            }
            else {
                entry2FieldValue = (0, lodash_1.get)(entry2.json, key);
            }
            if (!(0, lodash_1.isEqual)(excpectedValue, entry2FieldValue)) {
                return false;
            }
        }
        return true;
    });
    if (index === -1)
        return [];
    return [{ entry: data[index], index }];
}
function findMatches(input1, input2, fieldsToMatch, options) {
    let data1 = [...input1];
    let data2 = [...input2];
    if (options.joinMode === 'enrichInput2') {
        [data1, data2] = [data2, data1];
    }
    const disableDotNotation = options.disableDotNotation || false;
    const multipleMatches = options.multipleMatches || 'all';
    const filteredData = {
        matched: [],
        matched2: [],
        unmatched1: [],
        unmatched2: [],
    };
    const matchedInInput2 = new Set();
    matchesLoop: for (const entry1 of data1) {
        const lookup = {};
        fieldsToMatch.forEach((matchCase) => {
            let valueToCompare;
            if (disableDotNotation) {
                valueToCompare = entry1.json[matchCase.field1];
            }
            else {
                valueToCompare = (0, lodash_1.get)(entry1.json, matchCase.field1);
            }
            lookup[matchCase.field2] = valueToCompare;
        });
        for (const fieldValue of Object.values(lookup)) {
            if (fieldValue === undefined) {
                filteredData.unmatched1.push(entry1);
                continue matchesLoop;
            }
        }
        const foundedMatches = multipleMatches === 'all'
            ? findAllMatches(data2, lookup, disableDotNotation)
            : findFirstMatch(data2, lookup, disableDotNotation);
        const matches = foundedMatches.map((match) => match.entry);
        foundedMatches.map((match) => matchedInInput2.add(match.index));
        if (matches.length) {
            if (options.outputDataFrom === 'both' ||
                options.joinMode === 'enrichInput1' ||
                options.joinMode === 'enrichInput2') {
                matches.forEach((match) => {
                    filteredData.matched.push({
                        entry: entry1,
                        matches: [match],
                    });
                });
            }
            else {
                filteredData.matched.push({
                    entry: entry1,
                    matches,
                });
            }
        }
        else {
            filteredData.unmatched1.push(entry1);
        }
    }
    data2.forEach((entry, i) => {
        if (matchedInInput2.has(i)) {
            filteredData.matched2.push(entry);
        }
        else {
            filteredData.unmatched2.push(entry);
        }
    });
    return filteredData;
}
exports.findMatches = findMatches;
function mergeMatched(matched, clashResolveOptions, joinMode) {
    const returnData = [];
    let resolveClash = clashResolveOptions.resolveClash;
    const mergeIntoSingleObject = selectMergeMethod(clashResolveOptions);
    for (const match of matched) {
        let { entry, matches } = match;
        let json = {};
        let binary = {};
        if (resolveClash === 'addSuffix') {
            let suffix1 = '1';
            let suffix2 = '2';
            if (joinMode === 'enrichInput2') {
                [suffix1, suffix2] = [suffix2, suffix1];
            }
            [entry] = addSuffixToEntriesKeys([entry], suffix1);
            matches = addSuffixToEntriesKeys(matches, suffix2);
            json = mergeIntoSingleObject({ ...entry.json }, ...matches.map((match) => match.json));
            binary = mergeIntoSingleObject({ ...entry.binary }, ...matches.map((match) => match.binary));
        }
        else {
            let preferInput1 = 'preferInput1';
            let preferInput2 = 'preferInput2';
            if (joinMode === 'enrichInput2') {
                [preferInput1, preferInput2] = [preferInput2, preferInput1];
            }
            if (resolveClash === undefined) {
                resolveClash = 'preferInput2';
            }
            if (resolveClash === preferInput1) {
                const [firstMatch, ...restMatches] = matches;
                json = mergeIntoSingleObject({ ...firstMatch.json }, ...restMatches.map((match) => match.json), entry.json);
                binary = mergeIntoSingleObject({ ...firstMatch.binary }, ...restMatches.map((match) => match.binary), entry.binary);
            }
            if (resolveClash === preferInput2) {
                json = mergeIntoSingleObject({ ...entry.json }, ...matches.map((match) => match.json));
                binary = mergeIntoSingleObject({ ...entry.binary }, ...matches.map((match) => match.binary));
            }
        }
        const pairedItem = [
            entry.pairedItem,
            ...matches.map((m) => m.pairedItem),
        ];
        returnData.push({
            json,
            binary,
            pairedItem,
        });
    }
    return returnData;
}
exports.mergeMatched = mergeMatched;
function selectMergeMethod(clashResolveOptions) {
    const mergeMode = clashResolveOptions.mergeMode;
    if (clashResolveOptions.overrideEmpty) {
        function customizer(targetValue, srcValue) {
            if (srcValue === undefined || srcValue === null || srcValue === '') {
                return targetValue;
            }
        }
        if (mergeMode === 'deepMerge') {
            return (target, ...source) => {
                const targetCopy = Object.assign({}, target);
                return (0, lodash_1.mergeWith)(targetCopy, ...source, customizer);
            };
        }
        if (mergeMode === 'shallowMerge') {
            return (target, ...source) => {
                const targetCopy = Object.assign({}, target);
                return (0, lodash_1.assignWith)(targetCopy, ...source, customizer);
            };
        }
    }
    else {
        if (mergeMode === 'deepMerge') {
            return (target, ...source) => (0, lodash_1.merge)({}, target, ...source);
        }
        if (mergeMode === 'shallowMerge') {
            return (target, ...source) => (0, lodash_1.assign)({}, target, ...source);
        }
    }
    return (target, ...source) => (0, lodash_1.merge)({}, target, ...source);
}
exports.selectMergeMethod = selectMergeMethod;
function checkMatchFieldsInput(data) {
    if (data.length === 1 && data[0].field1 === '' && data[0].field2 === '') {
        throw new Error('You need to define at least one pair of fields in "Fields to Match" to match on');
    }
    for (const [index, pair] of data.entries()) {
        if (pair.field1 === '' || pair.field2 === '') {
            throw new Error(`You need to define both fields in "Fields to Match" for pair ${index + 1},
				 field 1 = '${pair.field1}'
				 field 2 = '${pair.field2}'`);
        }
    }
    return data;
}
exports.checkMatchFieldsInput = checkMatchFieldsInput;
function checkInput(input, fields, disableDotNotation, inputLabel) {
    for (const field of fields) {
        const isPresent = (input || []).some((entry) => {
            if (disableDotNotation) {
                return entry.json.hasOwnProperty(field);
            }
            return (0, lodash_1.get)(entry.json, field, undefined) !== undefined;
        });
        if (!isPresent) {
            throw new Error(`Field '${field}' is not present in any of items in '${inputLabel}'`);
        }
    }
    return input;
}
exports.checkInput = checkInput;
function addSourceField(data, sourceField) {
    return data.map((entry) => {
        const json = {
            ...entry.json,
            _source: sourceField,
        };
        return {
            ...entry,
            json,
        };
    });
}
exports.addSourceField = addSourceField;
//# sourceMappingURL=GenericFunctions.js.map