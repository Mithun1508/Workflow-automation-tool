"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Worker = void 0;
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const command_1 = require("@oclif/command");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const typeorm_1 = require("typeorm");
const src_1 = require("../src");
const Logger_1 = require("../src/Logger");
const config_1 = __importDefault(require("../config"));
const Queue = __importStar(require("../src/Queue"));
const UserManagementHelper_1 = require("../src/UserManagement/UserManagementHelper");
const WorkflowHelpers_1 = require("../src/WorkflowHelpers");
class Worker extends command_1.Command {
    static async stopProcess() {
        n8n_workflow_1.LoggerProxy.info(`Stopping n8n...`);
        Worker.jobQueue.pause(true);
        try {
            const externalHooks = (0, src_1.ExternalHooks)();
            await externalHooks.run('n8n.stop', []);
            const maxStopTime = config_1.default.getEnv('queue.bull.gracefulShutdownTimeout') * 1000;
            const stopTime = new Date().getTime() + maxStopTime;
            setTimeout(() => {
                process.exit(Worker.processExistCode);
            }, maxStopTime);
            let count = 0;
            while (Object.keys(Worker.runningJobs).length !== 0) {
                if (count++ % 4 === 0) {
                    const waitLeft = Math.ceil((stopTime - new Date().getTime()) / 1000);
                    n8n_workflow_1.LoggerProxy.info(`Waiting for ${Object.keys(Worker.runningJobs).length} active executions to finish... (wait ${waitLeft} more seconds)`);
                }
                await new Promise((resolve) => {
                    setTimeout(resolve, 500);
                });
            }
        }
        catch (error) {
            n8n_workflow_1.LoggerProxy.error('There was an error shutting down n8n.', error);
        }
        process.exit(Worker.processExistCode);
    }
    async runJob(job, nodeTypes) {
        const { executionId, loadStaticData } = job.data;
        const executionDb = await src_1.Db.collections.Execution.findOne(executionId);
        if (!executionDb) {
            n8n_workflow_1.LoggerProxy.error(`Worker failed to find data of execution "${executionId}" in database. Cannot continue.`, { executionId });
            throw new Error(`Unable to find data of execution "${executionId}" in database. Aborting execution.`);
        }
        const currentExecutionDb = src_1.ResponseHelper.unflattenExecutionData(executionDb);
        n8n_workflow_1.LoggerProxy.info(`Start job: ${job.id} (Workflow ID: ${currentExecutionDb.workflowData.id} | Execution: ${executionId})`);
        const workflowOwner = await (0, UserManagementHelper_1.getWorkflowOwner)(currentExecutionDb.workflowData.id.toString());
        let { staticData } = currentExecutionDb.workflowData;
        if (loadStaticData) {
            const findOptions = {
                select: ['id', 'staticData'],
            };
            const workflowData = await src_1.Db.collections.Workflow.findOne(currentExecutionDb.workflowData.id, findOptions);
            if (workflowData === undefined) {
                n8n_workflow_1.LoggerProxy.error('Worker execution failed because workflow could not be found in database.', {
                    workflowId: currentExecutionDb.workflowData.id,
                    executionId,
                });
                throw new Error(`The workflow with the ID "${currentExecutionDb.workflowData.id}" could not be found`);
            }
            staticData = workflowData.staticData;
        }
        let workflowTimeout = config_1.default.getEnv('executions.timeout');
        if (currentExecutionDb.workflowData.settings &&
            currentExecutionDb.workflowData.settings.executionTimeout) {
            workflowTimeout = currentExecutionDb.workflowData.settings.executionTimeout;
        }
        let executionTimeoutTimestamp;
        if (workflowTimeout > 0) {
            workflowTimeout = Math.min(workflowTimeout, config_1.default.getEnv('executions.maxTimeout'));
            executionTimeoutTimestamp = Date.now() + workflowTimeout * 1000;
        }
        const workflow = new n8n_workflow_1.Workflow({
            id: currentExecutionDb.workflowData.id,
            name: currentExecutionDb.workflowData.name,
            nodes: currentExecutionDb.workflowData.nodes,
            connections: currentExecutionDb.workflowData.connections,
            active: currentExecutionDb.workflowData.active,
            nodeTypes,
            staticData,
            settings: currentExecutionDb.workflowData.settings,
        });
        const additionalData = await src_1.WorkflowExecuteAdditionalData.getBase(workflowOwner.id, undefined, executionTimeoutTimestamp);
        additionalData.hooks = src_1.WorkflowExecuteAdditionalData.getWorkflowHooksWorkerExecuter(currentExecutionDb.mode, job.data.executionId, currentExecutionDb.workflowData, { retryOf: currentExecutionDb.retryOf });
        try {
            await (0, UserManagementHelper_1.checkPermissionsForExecution)(workflow, workflowOwner.id);
        }
        catch (error) {
            const failedExecution = (0, WorkflowHelpers_1.generateFailedExecutionFromError)(currentExecutionDb.mode, error, error.node);
            await additionalData.hooks.executeHookFunctions('workflowExecuteAfter', [failedExecution]);
            return {
                success: true,
            };
        }
        additionalData.hooks.hookFunctions.sendResponse = [
            async (response) => {
                const progress = {
                    executionId,
                    response: src_1.WebhookHelpers.encodeWebhookResponse(response),
                };
                await job.progress(progress);
            },
        ];
        additionalData.executionId = executionId;
        let workflowExecute;
        let workflowRun;
        if (currentExecutionDb.data !== undefined) {
            workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, currentExecutionDb.mode, currentExecutionDb.data);
            workflowRun = workflowExecute.processRunExecutionData(workflow);
        }
        else {
            workflowExecute = new n8n_core_1.WorkflowExecute(additionalData, currentExecutionDb.mode);
            workflowRun = workflowExecute.run(workflow);
        }
        Worker.runningJobs[job.id] = workflowRun;
        await workflowRun;
        delete Worker.runningJobs[job.id];
        return {
            success: true,
        };
    }
    async run() {
        const logger = (0, Logger_1.getLogger)();
        n8n_workflow_1.LoggerProxy.init(logger);
        console.info('Starting n8n worker...');
        process.on('SIGTERM', Worker.stopProcess);
        process.on('SIGINT', Worker.stopProcess);
        await (async () => {
            try {
                const { flags } = this.parse(Worker);
                const startDbInitPromise = src_1.Db.init().catch((error) => {
                    logger.error(`There was an error initializing DB: "${error.message}"`);
                    Worker.processExistCode = 1;
                    process.emit('SIGINT');
                    process.exit(1);
                });
                await n8n_core_1.UserSettings.prepareUserSettings();
                const loadNodesAndCredentials = (0, src_1.LoadNodesAndCredentials)();
                await loadNodesAndCredentials.init();
                const credentialsOverwrites = (0, src_1.CredentialsOverwrites)();
                await credentialsOverwrites.init();
                const externalHooks = (0, src_1.ExternalHooks)();
                await externalHooks.init();
                const nodeTypes = (0, src_1.NodeTypes)();
                await nodeTypes.init(loadNodesAndCredentials.nodeTypes);
                const credentialTypes = (0, src_1.CredentialTypes)();
                await credentialTypes.init(loadNodesAndCredentials.credentialTypes);
                await startDbInitPromise;
                const redisConnectionTimeoutLimit = config_1.default.getEnv('queue.bull.redis.timeoutThreshold');
                Worker.jobQueue = Queue.getInstance().getBullObjectInstance();
                Worker.jobQueue.process(flags.concurrency, async (job) => this.runJob(job, nodeTypes));
                const versions = await src_1.GenericHelpers.getVersions();
                const instanceId = await n8n_core_1.UserSettings.getInstanceId();
                src_1.InternalHooksManager.init(instanceId, versions.cli, nodeTypes);
                const binaryDataConfig = config_1.default.getEnv('binaryDataManager');
                await n8n_core_1.BinaryDataManager.init(binaryDataConfig);
                console.info('\nn8n worker is now ready');
                console.info(` * Version: ${versions.cli}`);
                console.info(` * Concurrency: ${flags.concurrency}`);
                console.info('');
                Worker.jobQueue.on('global:progress', (jobId, progress) => {
                    if (progress === -1) {
                        if (Worker.runningJobs[jobId] !== undefined) {
                            Worker.runningJobs[jobId].cancel();
                            delete Worker.runningJobs[jobId];
                        }
                    }
                });
                let lastTimer = 0;
                let cumulativeTimeout = 0;
                Worker.jobQueue.on('error', (error) => {
                    if (error.toString().includes('ECONNREFUSED')) {
                        const now = Date.now();
                        if (now - lastTimer > 30000) {
                            lastTimer = now;
                            cumulativeTimeout = 0;
                        }
                        else {
                            cumulativeTimeout += now - lastTimer;
                            lastTimer = now;
                            if (cumulativeTimeout > redisConnectionTimeoutLimit) {
                                logger.error(`Unable to connect to Redis after ${redisConnectionTimeoutLimit}. Exiting process.`);
                                process.exit(1);
                            }
                        }
                        logger.warn('Redis unavailable - trying to reconnect...');
                    }
                    else if (error.toString().includes('Error initializing Lua scripts')) {
                        logger.error('Error initializing worker.');
                        process.exit(2);
                    }
                    else {
                        logger.error('Error from queue: ', error);
                        throw error;
                    }
                });
                if (config_1.default.getEnv('queue.health.active')) {
                    const port = config_1.default.getEnv('queue.health.port');
                    const app = (0, express_1.default)();
                    app.disable('x-powered-by');
                    const server = http_1.default.createServer(app);
                    app.get('/healthz', async (req, res) => {
                        n8n_workflow_1.LoggerProxy.debug('Health check started!');
                        const connection = (0, typeorm_1.getConnectionManager)().get();
                        try {
                            if (!connection.isConnected) {
                                throw new Error('No active database connection!');
                            }
                            await connection.query('SELECT 1');
                        }
                        catch (e) {
                            n8n_workflow_1.LoggerProxy.error('No Database connection!', e);
                            const error = new src_1.ResponseHelper.ResponseError('No Database connection!', undefined, 503);
                            return src_1.ResponseHelper.sendErrorResponse(res, error);
                        }
                        try {
                            await Worker.jobQueue.client.ping();
                        }
                        catch (e) {
                            n8n_workflow_1.LoggerProxy.error('No Redis connection!', e);
                            const error = new src_1.ResponseHelper.ResponseError('No Redis connection!', undefined, 503);
                            return src_1.ResponseHelper.sendErrorResponse(res, error);
                        }
                        const responseData = {
                            status: 'ok',
                        };
                        n8n_workflow_1.LoggerProxy.debug('Health check completed successfully!');
                        src_1.ResponseHelper.sendSuccessResponse(res, responseData, true, 200);
                    });
                    server.listen(port, () => {
                        console.info(`\nn8n worker health check via, port ${port}`);
                    });
                    server.on('error', (error) => {
                        if (error.code === 'EADDRINUSE') {
                            console.log(`n8n's port ${port} is already in use. Do you have the n8n main process running on that port?`);
                            process.exit(1);
                        }
                    });
                }
            }
            catch (error) {
                logger.error(`Worker process cannot continue. "${error.message}"`);
                Worker.processExistCode = 1;
                process.emit('SIGINT');
                process.exit(1);
            }
        })();
    }
}
exports.Worker = Worker;
Worker.description = '\nStarts a n8n worker';
Worker.examples = [`$ n8n worker --concurrency=5`];
Worker.flags = {
    help: command_1.flags.help({ char: 'h' }),
    concurrency: command_1.flags.integer({
        default: 10,
        description: 'How many jobs can run in parallel.',
    }),
};
Worker.runningJobs = {};
Worker.processExistCode = 0;
//# sourceMappingURL=worker.js.map