"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInstance = exports.ActiveWorkflowRunner = void 0;
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const _1 = require(".");
const config_1 = __importDefault(require("../config"));
const WorkflowHelpers_1 = require("./WorkflowHelpers");
const ActiveExecutions = __importStar(require("./ActiveExecutions"));
const GenericHelpers_1 = require("./GenericHelpers");
const constants_1 = require("./constants");
const activeExecutions = ActiveExecutions.getInstance();
const WEBHOOK_PROD_UNREGISTERED_HINT = `The workflow must be active for a production URL to run successfully. You can activate the workflow using the toggle in the top-right of the editor. Note that unlike test URL calls, production URL calls aren't shown on the canvas (only in the executions list)`;
class ActiveWorkflowRunner {
    constructor() {
        this.activeWorkflows = null;
        this.activationErrors = {};
        this.queuedWorkflowActivations = {};
    }
    async init() {
        const workflowsData = (await _1.Db.collections.Workflow.find({
            where: { active: true },
            relations: ['shared', 'shared.user', 'shared.user.globalRole'],
        }));
        if (!config_1.default.getEnv('endpoints.skipWebhoooksDeregistrationOnShutdown')) {
            await _1.Db.collections.Webhook.clear();
        }
        this.activeWorkflows = new n8n_core_1.ActiveWorkflows();
        if (workflowsData.length !== 0) {
            console.info(' ================================');
            console.info('   Start Active Workflows:');
            console.info(' ================================');
            for (const workflowData of workflowsData) {
                console.log(`   - ${workflowData.name} (ID: ${workflowData.id})`);
                n8n_workflow_1.LoggerProxy.debug(`Initializing active workflow "${workflowData.name}" (startup)`, {
                    workflowName: workflowData.name,
                    workflowId: workflowData.id,
                });
                try {
                    await this.add(workflowData.id.toString(), 'init', workflowData);
                    n8n_workflow_1.LoggerProxy.verbose(`Successfully started workflow "${workflowData.name}"`, {
                        workflowName: workflowData.name,
                        workflowId: workflowData.id,
                    });
                    console.log(`     => Started`);
                }
                catch (error) {
                    console.log(`     => ERROR: Workflow could not be activated on first try, keep on trying`);
                    console.log(`               ${error.message}`);
                    n8n_workflow_1.LoggerProxy.error(`Issue on intital workflow activation try "${workflowData.name}" (startup)`, {
                        workflowName: workflowData.name,
                        workflowId: workflowData.id,
                    });
                    this.executeErrorWorkflow(error, workflowData, 'internal');
                    this.addQueuedWorkflowActivation('init', workflowData);
                }
            }
            n8n_workflow_1.LoggerProxy.verbose('Finished initializing active workflows (startup)');
        }
        const externalHooks = (0, _1.ExternalHooks)();
        await externalHooks.run('activeWorkflows.initialized', []);
    }
    async initWebhooks() {
        this.activeWorkflows = new n8n_core_1.ActiveWorkflows();
    }
    async removeAll() {
        let activeWorkflowIds = [];
        n8n_workflow_1.LoggerProxy.verbose('Call to remove all active workflows received (removeAll)');
        if (this.activeWorkflows !== null) {
            activeWorkflowIds.push.apply(activeWorkflowIds, this.activeWorkflows.allActiveWorkflows());
        }
        const activeWorkflows = await this.getActiveWorkflows();
        activeWorkflowIds = [
            ...activeWorkflowIds,
            ...activeWorkflows.map((workflow) => workflow.id.toString()),
        ];
        activeWorkflowIds = Array.from(new Set(activeWorkflowIds));
        const removePromises = [];
        for (const workflowId of activeWorkflowIds) {
            removePromises.push(this.remove(workflowId));
        }
        await Promise.all(removePromises);
    }
    async executeWebhook(httpMethod, path, req, res) {
        n8n_workflow_1.LoggerProxy.debug(`Received webhook "${httpMethod}" for path "${path}"`);
        if (this.activeWorkflows === null) {
            throw new _1.ResponseHelper.ResponseError('The "activeWorkflows" instance did not get initialized yet.', 404, 404);
        }
        req.params = {};
        if (path.endsWith('/')) {
            path = path.slice(0, -1);
        }
        let webhook = (await _1.Db.collections.Webhook.findOne({
            webhookPath: path,
            method: httpMethod,
        }));
        let webhookId;
        if (webhook === undefined) {
            const pathElements = path.split('/');
            webhookId = pathElements.shift();
            const dynamicWebhooks = await _1.Db.collections.Webhook.find({
                webhookId,
                method: httpMethod,
                pathLength: pathElements.length,
            });
            if (dynamicWebhooks === undefined || dynamicWebhooks.length === 0) {
                throw new _1.ResponseHelper.ResponseError(`The requested webhook "${httpMethod} ${path}" is not registered.`, 404, 404, WEBHOOK_PROD_UNREGISTERED_HINT);
            }
            let maxMatches = 0;
            const pathElementsSet = new Set(pathElements);
            dynamicWebhooks.forEach((dynamicWebhook) => {
                const staticElements = dynamicWebhook.webhookPath
                    .split('/')
                    .filter((ele) => !ele.startsWith(':'));
                const allStaticExist = staticElements.every((staticEle) => pathElementsSet.has(staticEle));
                if (allStaticExist && staticElements.length > maxMatches) {
                    maxMatches = staticElements.length;
                    webhook = dynamicWebhook;
                }
                else if (staticElements.length === 0 && !webhook) {
                    webhook = dynamicWebhook;
                }
            });
            if (webhook === undefined) {
                throw new _1.ResponseHelper.ResponseError(`The requested webhook "${httpMethod} ${path}" is not registered.`, 404, 404, WEBHOOK_PROD_UNREGISTERED_HINT);
            }
            path = webhook.webhookPath;
            webhook.webhookPath.split('/').forEach((ele, index) => {
                if (ele.startsWith(':')) {
                    req.params[ele.slice(1)] = pathElements[index];
                }
            });
        }
        const workflowData = await _1.Db.collections.Workflow.findOne(webhook.workflowId, {
            relations: ['shared', 'shared.user', 'shared.user.globalRole'],
        });
        if (workflowData === undefined) {
            throw new _1.ResponseHelper.ResponseError(`Could not find workflow with id "${webhook.workflowId}"`, 404, 404);
        }
        const nodeTypes = (0, _1.NodeTypes)();
        const workflow = new n8n_workflow_1.Workflow({
            id: webhook.workflowId.toString(),
            name: workflowData.name,
            nodes: workflowData.nodes,
            connections: workflowData.connections,
            active: workflowData.active,
            nodeTypes,
            staticData: workflowData.staticData,
            settings: workflowData.settings,
        });
        const additionalData = await _1.WorkflowExecuteAdditionalData.getBase(workflowData.shared[0].user.id);
        const webhookData = n8n_workflow_1.NodeHelpers.getNodeWebhooks(workflow, workflow.getNode(webhook.node), additionalData).filter((webhook) => {
            return webhook.httpMethod === httpMethod && webhook.path === path;
        })[0];
        const workflowStartNode = workflow.getNode(webhookData.node);
        if (workflowStartNode === null) {
            throw new _1.ResponseHelper.ResponseError('Could not find node to process webhook.', 404, 404);
        }
        return new Promise((resolve, reject) => {
            const executionMode = 'webhook';
            _1.WebhookHelpers.executeWebhook(workflow, webhookData, workflowData, workflowStartNode, executionMode, undefined, undefined, undefined, req, res, (error, data) => {
                if (error !== null) {
                    return reject(error);
                }
                resolve(data);
            });
        });
    }
    async getWebhookMethods(path) {
        const webhooks = await _1.Db.collections.Webhook.find({ webhookPath: path });
        const webhookMethods = webhooks.map((webhook) => webhook.method);
        return webhookMethods;
    }
    async getActiveWorkflows(user) {
        let activeWorkflows = [];
        if (!user || user.globalRole.name === 'owner') {
            activeWorkflows = await _1.Db.collections.Workflow.find({
                select: ['id'],
                where: { active: true },
            });
        }
        else {
            const shared = await _1.Db.collections.SharedWorkflow.find({
                relations: ['workflow'],
                where: (0, WorkflowHelpers_1.whereClause)({
                    user,
                    entityType: 'workflow',
                }),
            });
            activeWorkflows = shared.reduce((acc, cur) => {
                if (cur.workflow.active)
                    acc.push(cur.workflow);
                return acc;
            }, []);
        }
        return activeWorkflows.filter((workflow) => this.activationErrors[workflow.id] === undefined);
    }
    async isActive(id) {
        const workflow = await _1.Db.collections.Workflow.findOne(id);
        return !!(workflow === null || workflow === void 0 ? void 0 : workflow.active);
    }
    getActivationError(id) {
        if (this.activationErrors[id] === undefined) {
            return undefined;
        }
        return this.activationErrors[id];
    }
    async addWorkflowWebhooks(workflow, additionalData, mode, activation) {
        const webhooks = _1.WebhookHelpers.getWorkflowWebhooks(workflow, additionalData, undefined, true);
        let path = '';
        for (const webhookData of webhooks) {
            const node = workflow.getNode(webhookData.node);
            node.name = webhookData.node;
            path = webhookData.path;
            const webhook = {
                workflowId: webhookData.workflowId,
                webhookPath: path,
                node: node.name,
                method: webhookData.httpMethod,
            };
            if (webhook.webhookPath.startsWith('/')) {
                webhook.webhookPath = webhook.webhookPath.slice(1);
            }
            if (webhook.webhookPath.endsWith('/')) {
                webhook.webhookPath = webhook.webhookPath.slice(0, -1);
            }
            if ((path.startsWith(':') || path.includes('/:')) && node.webhookId) {
                webhook.webhookId = node.webhookId;
                webhook.pathLength = webhook.webhookPath.split('/').length;
            }
            try {
                await _1.Db.collections.Webhook.insert(webhook);
                const webhookExists = await workflow.runWebhookMethod('checkExists', webhookData, n8n_core_1.NodeExecuteFunctions, mode, activation, false);
                if (webhookExists !== true) {
                    await workflow.runWebhookMethod('create', webhookData, n8n_core_1.NodeExecuteFunctions, mode, activation, false);
                }
            }
            catch (error) {
                if (activation === 'init' &&
                    config_1.default.getEnv('endpoints.skipWebhoooksDeregistrationOnShutdown') &&
                    error.name === 'QueryFailedError') {
                    continue;
                }
                try {
                    await this.removeWorkflowWebhooks(workflow.id);
                }
                catch (error) {
                    console.error(`Could not remove webhooks of workflow "${workflow.id}" because of error: "${error.message}"`);
                }
                if (error.name === 'QueryFailedError') {
                    error.message = `The URL path that the "${webhook.node}" node uses is already taken. Please change it to something else.`;
                }
                else if (error.detail) {
                    error.message = error.detail;
                }
                throw error;
            }
        }
        await _1.WorkflowHelpers.saveStaticData(workflow);
    }
    async removeWorkflowWebhooks(workflowId) {
        const workflowData = await _1.Db.collections.Workflow.findOne(workflowId, {
            relations: ['shared', 'shared.user', 'shared.user.globalRole'],
        });
        if (workflowData === undefined) {
            throw new Error(`Could not find workflow with id "${workflowId}"`);
        }
        const nodeTypes = (0, _1.NodeTypes)();
        const workflow = new n8n_workflow_1.Workflow({
            id: workflowId,
            name: workflowData.name,
            nodes: workflowData.nodes,
            connections: workflowData.connections,
            active: workflowData.active,
            nodeTypes,
            staticData: workflowData.staticData,
            settings: workflowData.settings,
        });
        const mode = 'internal';
        const additionalData = await _1.WorkflowExecuteAdditionalData.getBase(workflowData.shared[0].user.id);
        const webhooks = _1.WebhookHelpers.getWorkflowWebhooks(workflow, additionalData, undefined, true);
        for (const webhookData of webhooks) {
            await workflow.runWebhookMethod('delete', webhookData, n8n_core_1.NodeExecuteFunctions, mode, 'update', false);
        }
        await _1.WorkflowHelpers.saveStaticData(workflow);
        const webhook = {
            workflowId: workflowData.id,
        };
        await _1.Db.collections.Webhook.delete(webhook);
    }
    async runWorkflow(workflowData, node, data, additionalData, mode, responsePromise) {
        const nodeExecutionStack = [
            {
                node,
                data: {
                    main: data,
                },
                source: null,
            },
        ];
        const executionData = {
            startData: {},
            resultData: {
                runData: {},
            },
            executionData: {
                contextData: {},
                nodeExecutionStack,
                waitingExecution: {},
                waitingExecutionSource: {},
            },
        };
        const runData = {
            userId: additionalData.userId,
            executionMode: mode,
            executionData,
            workflowData,
        };
        const workflowRunner = new _1.WorkflowRunner();
        return workflowRunner.run(runData, true, undefined, undefined, responsePromise);
    }
    getExecutePollFunctions(workflowData, additionalData, mode, activation) {
        return (workflow, node) => {
            const returnFunctions = n8n_core_1.NodeExecuteFunctions.getExecutePollFunctions(workflow, node, additionalData, mode, activation);
            returnFunctions.__emit = async (data) => {
                if (data instanceof Error) {
                    await (0, GenericHelpers_1.createErrorExecution)(data, node, workflowData, workflow, mode);
                    this.executeErrorWorkflow(data, workflowData, mode);
                    return;
                }
                n8n_workflow_1.LoggerProxy.debug(`Received event to trigger execution for workflow "${workflow.name}"`);
                _1.WorkflowHelpers.saveStaticData(workflow);
                this.runWorkflow(workflowData, node, data, additionalData, mode);
            };
            return returnFunctions;
        };
    }
    getExecuteTriggerFunctions(workflowData, additionalData, mode, activation) {
        return (workflow, node) => {
            const returnFunctions = n8n_core_1.NodeExecuteFunctions.getExecuteTriggerFunctions(workflow, node, additionalData, mode, activation);
            returnFunctions.emit = (data, responsePromise, donePromise) => {
                n8n_workflow_1.LoggerProxy.debug(`Received trigger for workflow "${workflow.name}"`);
                _1.WorkflowHelpers.saveStaticData(workflow);
                const executePromise = this.runWorkflow(workflowData, node, data, additionalData, mode, responsePromise);
                if (donePromise) {
                    executePromise.then((executionId) => {
                        activeExecutions
                            .getPostExecutePromise(executionId)
                            .then(donePromise.resolve)
                            .catch(donePromise.reject);
                    });
                }
                else {
                    executePromise.catch(console.error);
                }
            };
            returnFunctions.emitError = async (error) => {
                var _a;
                n8n_workflow_1.LoggerProxy.info(`The trigger node "${node.name}" of workflow "${workflowData.name}" failed with the error: "${error.message}". Will try to reactivate.`, {
                    nodeName: node.name,
                    workflowId: workflowData.id.toString(),
                    workflowName: workflowData.name,
                });
                await ((_a = this.activeWorkflows) === null || _a === void 0 ? void 0 : _a.remove(workflowData.id.toString()));
                this.activationErrors[workflowData.id.toString()] = {
                    time: new Date().getTime(),
                    error: {
                        message: error.message,
                    },
                };
                const activationError = new n8n_workflow_1.WorkflowActivationError(`There was a problem with the trigger node "${node.name}", for that reason did the workflow had to be deactivated`, { cause: error, node });
                this.executeErrorWorkflow(activationError, workflowData, mode);
                this.addQueuedWorkflowActivation(activation, workflowData);
            };
            return returnFunctions;
        };
    }
    executeErrorWorkflow(error, workflowData, mode) {
        const fullRunData = {
            data: {
                resultData: {
                    error,
                    runData: {},
                },
            },
            finished: false,
            mode,
            startedAt: new Date(),
            stoppedAt: new Date(),
        };
        _1.WorkflowExecuteAdditionalData.executeErrorWorkflow(workflowData, fullRunData, mode);
    }
    async add(workflowId, activation, workflowData) {
        if (this.activeWorkflows === null) {
            throw new Error(`The "activeWorkflows" instance did not get initialized yet.`);
        }
        let workflowInstance;
        try {
            if (workflowData === undefined) {
                workflowData = (await _1.Db.collections.Workflow.findOne(workflowId, {
                    relations: ['shared', 'shared.user', 'shared.user.globalRole'],
                }));
            }
            if (!workflowData) {
                throw new Error(`Could not find workflow with id "${workflowId}".`);
            }
            const nodeTypes = (0, _1.NodeTypes)();
            workflowInstance = new n8n_workflow_1.Workflow({
                id: workflowId,
                name: workflowData.name,
                nodes: workflowData.nodes,
                connections: workflowData.connections,
                active: workflowData.active,
                nodeTypes,
                staticData: workflowData.staticData,
                settings: workflowData.settings,
            });
            const canBeActivated = workflowInstance.checkIfWorkflowCanBeActivated([
                'n8n-nodes-base.start',
            ]);
            if (!canBeActivated) {
                n8n_workflow_1.LoggerProxy.error(`Unable to activate workflow "${workflowData.name}"`);
                throw new Error(`The workflow can not be activated because it does not contain any nodes which could start the workflow. Only workflows which have trigger or webhook nodes can be activated.`);
            }
            const mode = 'trigger';
            const additionalData = await _1.WorkflowExecuteAdditionalData.getBase(workflowData.shared[0].user.id);
            const getTriggerFunctions = this.getExecuteTriggerFunctions(workflowData, additionalData, mode, activation);
            const getPollFunctions = this.getExecutePollFunctions(workflowData, additionalData, mode, activation);
            await this.addWorkflowWebhooks(workflowInstance, additionalData, mode, activation);
            if (workflowInstance.getTriggerNodes().length !== 0 ||
                workflowInstance.getPollNodes().length !== 0) {
                await this.activeWorkflows.add(workflowId, workflowInstance, additionalData, mode, activation, getTriggerFunctions, getPollFunctions);
                n8n_workflow_1.LoggerProxy.verbose(`Successfully activated workflow "${workflowData.name}"`, {
                    workflowId,
                    workflowName: workflowData.name,
                });
            }
            this.removeQueuedWorkflowActivation(workflowId);
            if (this.activationErrors[workflowId] !== undefined) {
                delete this.activationErrors[workflowId];
            }
        }
        catch (error) {
            this.activationErrors[workflowId] = {
                time: new Date().getTime(),
                error: {
                    message: error.message,
                },
            };
            throw error;
        }
        await _1.WorkflowHelpers.saveStaticData(workflowInstance);
    }
    addQueuedWorkflowActivation(activationMode, workflowData) {
        const workflowId = workflowData.id.toString();
        const workflowName = workflowData.name;
        const retryFunction = async () => {
            n8n_workflow_1.LoggerProxy.info(`Try to activate workflow "${workflowName}" (${workflowId})`, {
                workflowId,
                workflowName,
            });
            try {
                await this.add(workflowId, activationMode, workflowData);
            }
            catch (error) {
                let lastTimeout = this.queuedWorkflowActivations[workflowId].lastTimeout;
                if (lastTimeout < constants_1.WORKFLOW_REACTIVATE_MAX_TIMEOUT) {
                    lastTimeout = Math.min(lastTimeout * 2, constants_1.WORKFLOW_REACTIVATE_MAX_TIMEOUT);
                }
                n8n_workflow_1.LoggerProxy.info(` -> Activation of workflow "${workflowName}" (${workflowId}) did fail with error: "${error.message}" | retry in ${Math.floor(lastTimeout / 1000)} seconds`, {
                    workflowId,
                    workflowName,
                });
                this.queuedWorkflowActivations[workflowId].lastTimeout = lastTimeout;
                this.queuedWorkflowActivations[workflowId].timeout = setTimeout(retryFunction, lastTimeout);
                return;
            }
            n8n_workflow_1.LoggerProxy.info(` -> Activation of workflow "${workflowName}" (${workflowId}) was successful!`, {
                workflowId,
                workflowName,
            });
        };
        this.removeQueuedWorkflowActivation(workflowId);
        this.queuedWorkflowActivations[workflowId] = {
            activationMode,
            lastTimeout: constants_1.WORKFLOW_REACTIVATE_INITIAL_TIMEOUT,
            timeout: setTimeout(retryFunction, constants_1.WORKFLOW_REACTIVATE_INITIAL_TIMEOUT),
            workflowData,
        };
    }
    removeQueuedWorkflowActivation(workflowId) {
        if (this.queuedWorkflowActivations[workflowId]) {
            clearTimeout(this.queuedWorkflowActivations[workflowId].timeout);
            delete this.queuedWorkflowActivations[workflowId];
        }
    }
    removeAllQueuedWorkflowActivations() {
        for (const workflowId in this.queuedWorkflowActivations) {
            this.removeQueuedWorkflowActivation(workflowId);
        }
    }
    async remove(workflowId) {
        if (this.activeWorkflows !== null) {
            try {
                await this.removeWorkflowWebhooks(workflowId);
            }
            catch (error) {
                console.error(`Could not remove webhooks of workflow "${workflowId}" because of error: "${error.message}"`);
            }
            if (this.activationErrors[workflowId] !== undefined) {
                delete this.activationErrors[workflowId];
            }
            if (this.queuedWorkflowActivations[workflowId] !== undefined) {
                this.removeQueuedWorkflowActivation(workflowId);
            }
            if (this.activeWorkflows.isActive(workflowId)) {
                await this.activeWorkflows.remove(workflowId);
                n8n_workflow_1.LoggerProxy.verbose(`Successfully deactivated workflow "${workflowId}"`, { workflowId });
            }
            return;
        }
        throw new Error(`The "activeWorkflows" instance did not get initialized yet.`);
    }
}
exports.ActiveWorkflowRunner = ActiveWorkflowRunner;
let workflowRunnerInstance;
function getInstance() {
    if (workflowRunnerInstance === undefined) {
        workflowRunnerInstance = new ActiveWorkflowRunner();
    }
    return workflowRunnerInstance;
}
exports.getInstance = getInstance;
//# sourceMappingURL=ActiveWorkflowRunner.js.map