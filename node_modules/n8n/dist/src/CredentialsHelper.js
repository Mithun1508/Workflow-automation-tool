"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCredentialsFromCredentialsEntity = exports.getCredentialWithoutUser = exports.getCredentialForUser = exports.whereClause = exports.CredentialsHelper = void 0;
const n8n_core_1 = require("n8n-core");
const lodash_1 = require("lodash");
const n8n_workflow_1 = require("n8n-workflow");
const _1 = require(".");
const mockNodeTypes = {
    nodeTypes: {},
    init: async (nodeTypes) => { },
    getAll() {
        return Object.values(this.nodeTypes).map((data) => data.type);
    },
    getByNameAndVersion(nodeType, version) {
        if (this.nodeTypes[nodeType] === undefined) {
            return undefined;
        }
        return n8n_workflow_1.NodeHelpers.getVersionedNodeType(this.nodeTypes[nodeType].type, version);
    },
};
class CredentialsHelper extends n8n_workflow_1.ICredentialsHelper {
    constructor() {
        super(...arguments);
        this.credentialTypes = (0, _1.CredentialTypes)();
    }
    async authenticate(credentials, typeName, incomingRequestOptions, workflow, node, defaultTimezone) {
        const requestOptions = incomingRequestOptions;
        const credentialType = this.credentialTypes.getByName(typeName);
        if (credentialType.authenticate) {
            if (typeof credentialType.authenticate === 'function') {
                return credentialType.authenticate(credentials, requestOptions);
            }
            if (typeof credentialType.authenticate === 'object') {
                let keyResolved;
                let valueResolved;
                const { authenticate } = credentialType;
                if (requestOptions.headers === undefined) {
                    requestOptions.headers = {};
                }
                if (authenticate.type === 'generic') {
                    Object.entries(authenticate.properties).forEach(([outerKey, outerValue]) => {
                        Object.entries(outerValue).forEach(([key, value]) => {
                            keyResolved = this.resolveValue(key, { $credentials: credentials }, workflow, node, defaultTimezone);
                            valueResolved = this.resolveValue(value, { $credentials: credentials }, workflow, node, defaultTimezone);
                            if (!requestOptions[outerKey]) {
                                requestOptions[outerKey] = {};
                            }
                            requestOptions[outerKey][keyResolved] = valueResolved;
                        });
                    });
                }
            }
        }
        return requestOptions;
    }
    async preAuthentication(helpers, credentials, typeName, node, credentialsExpired) {
        var _a;
        const credentialType = this.credentialTypes.getByName(typeName);
        const expirableProperty = credentialType.properties.find((property) => { var _a; return property.type === 'hidden' && ((_a = property === null || property === void 0 ? void 0 : property.typeOptions) === null || _a === void 0 ? void 0 : _a.expirable) === true; });
        if (expirableProperty === undefined || expirableProperty.name === undefined) {
            return undefined;
        }
        const isTestingCredentials = ((_a = node === null || node === void 0 ? void 0 : node.parameters) === null || _a === void 0 ? void 0 : _a.temp) === '' && (node === null || node === void 0 ? void 0 : node.type) === 'n8n-nodes-base.noOp';
        if (credentialType.preAuthentication) {
            if (typeof credentialType.preAuthentication === 'function') {
                if (credentials[expirableProperty === null || expirableProperty === void 0 ? void 0 : expirableProperty.name] === '' ||
                    credentialsExpired ||
                    isTestingCredentials) {
                    const output = await credentialType.preAuthentication.call(helpers, credentials);
                    if (output[expirableProperty.name] === undefined) {
                        return undefined;
                    }
                    if (node.credentials) {
                        await this.updateCredentials(node.credentials[credentialType.name], credentialType.name, Object.assign(credentials, output));
                        return Object.assign(credentials, output);
                    }
                }
            }
        }
        return undefined;
    }
    resolveValue(parameterValue, additionalKeys, workflow, node, defaultTimezone) {
        if (parameterValue.charAt(0) !== '=') {
            return parameterValue;
        }
        const returnValue = workflow.expression.getSimpleParameterValue(node, parameterValue, 'internal', defaultTimezone, additionalKeys, undefined, '');
        if (!returnValue) {
            return '';
        }
        return returnValue.toString();
    }
    getParentTypes(typeName) {
        const credentialType = this.credentialTypes.getByName(typeName);
        if (credentialType === undefined || credentialType.extends === undefined) {
            return [];
        }
        let types = [];
        credentialType.extends.forEach((type) => {
            types = [...types, type, ...this.getParentTypes(type)];
        });
        return types;
    }
    async getCredentials(nodeCredential, type, userId) {
        if (!nodeCredential.id) {
            throw new Error(`Credential "${nodeCredential.name}" of type "${type}" has no ID.`);
        }
        const credential = userId
            ? await _1.Db.collections.SharedCredentials.findOneOrFail({
                relations: ['credentials'],
                where: { credentials: { id: nodeCredential.id, type }, user: { id: userId } },
            }).then((shared) => shared.credentials)
            : await _1.Db.collections.Credentials.findOneOrFail({ id: nodeCredential.id, type });
        if (!credential) {
            throw new Error(`Credential with ID "${nodeCredential.id}" does not exist for type "${type}".`);
        }
        return new n8n_core_1.Credentials({ id: credential.id.toString(), name: credential.name }, credential.type, credential.nodesAccess, credential.data);
    }
    getCredentialsProperties(type) {
        const credentialTypeData = this.credentialTypes.getByName(type);
        if (credentialTypeData === undefined) {
            throw new Error(`The credentials of type "${type}" are not known.`);
        }
        if (credentialTypeData.extends === undefined) {
            return credentialTypeData.properties;
        }
        const combineProperties = [];
        for (const credentialsTypeName of credentialTypeData.extends) {
            const mergeCredentialProperties = this.getCredentialsProperties(credentialsTypeName);
            n8n_workflow_1.NodeHelpers.mergeNodeProperties(combineProperties, mergeCredentialProperties);
        }
        n8n_workflow_1.NodeHelpers.mergeNodeProperties(combineProperties, credentialTypeData.properties);
        return combineProperties;
    }
    async getDecrypted(nodeCredentials, type, mode, defaultTimezone, raw, expressionResolveValues) {
        const credentials = await this.getCredentials(nodeCredentials, type);
        const decryptedDataOriginal = credentials.getData(this.encryptionKey);
        if (raw === true) {
            return decryptedDataOriginal;
        }
        return this.applyDefaultsAndOverwrites(decryptedDataOriginal, type, mode, defaultTimezone, expressionResolveValues);
    }
    applyDefaultsAndOverwrites(decryptedDataOriginal, type, mode, defaultTimezone, expressionResolveValues) {
        const credentialsProperties = this.getCredentialsProperties(type);
        let decryptedData = n8n_workflow_1.NodeHelpers.getNodeParameters(credentialsProperties, decryptedDataOriginal, true, false, null);
        if (decryptedDataOriginal.oauthTokenData !== undefined) {
            decryptedData.oauthTokenData = decryptedDataOriginal.oauthTokenData;
        }
        if (expressionResolveValues) {
            const timezone = expressionResolveValues.workflow.settings.timezone || defaultTimezone;
            try {
                decryptedData = expressionResolveValues.workflow.expression.getParameterValue(decryptedData, expressionResolveValues.runExecutionData, expressionResolveValues.runIndex, expressionResolveValues.itemIndex, expressionResolveValues.node.name, expressionResolveValues.connectionInputData, mode, timezone, {}, undefined, false, decryptedData);
            }
            catch (e) {
                e.message += ' [Error resolving credentials]';
                throw e;
            }
        }
        else {
            const node = {
                name: '',
                typeVersion: 1,
                type: 'mock',
                position: [0, 0],
                parameters: {},
            };
            const workflow = new n8n_workflow_1.Workflow({
                nodes: [node],
                connections: {},
                active: false,
                nodeTypes: mockNodeTypes,
            });
            decryptedData = workflow.expression.getComplexParameterValue(node, decryptedData, mode, defaultTimezone, {}, undefined, undefined, decryptedData);
        }
        const credentialsOverwrites = (0, _1.CredentialsOverwrites)();
        return credentialsOverwrites.applyOverwrite(type, decryptedData);
    }
    async updateCredentials(nodeCredentials, type, data) {
        const credentials = await this.getCredentials(nodeCredentials, type);
        if (!_1.Db.isInitialized) {
            await _1.Db.init();
        }
        credentials.setData(data, this.encryptionKey);
        const newCredentialsData = credentials.getDataToSave();
        newCredentialsData.updatedAt = new Date();
        const findQuery = {
            id: credentials.id,
            type,
        };
        await _1.Db.collections.Credentials.update(findQuery, newCredentialsData);
    }
    getCredentialTestFunction(credentialType, nodeToTestWith) {
        var _a, _b, _c, _d, _e;
        const nodeTypes = (0, _1.NodeTypes)();
        const allNodes = nodeTypes.getAll();
        for (let i = 0; i < allNodes.length; i++) {
            const node = allNodes[i];
            if (nodeToTestWith && node.description.name !== nodeToTestWith) {
                continue;
            }
            const allNodeTypes = [];
            if (node instanceof n8n_workflow_1.VersionedNodeType) {
                allNodeTypes.push(...Object.values(node.nodeVersions));
            }
            else {
                allNodeTypes.push(node);
            }
            for (const nodeType of allNodeTypes) {
                for (const credential of (_a = nodeType.description.credentials) !== null && _a !== void 0 ? _a : []) {
                    if (credential.name === credentialType && !!credential.testedBy) {
                        if (typeof credential.testedBy === 'string') {
                            if (Object.prototype.hasOwnProperty.call(node, 'nodeVersions')) {
                                const versions = Object.keys(node.nodeVersions)
                                    .sort()
                                    .reverse();
                                for (const version of versions) {
                                    const versionedNode = node.nodeVersions[parseInt(version, 10)];
                                    if (((_b = versionedNode.methods) === null || _b === void 0 ? void 0 : _b.credentialTest) &&
                                        ((_c = versionedNode.methods) === null || _c === void 0 ? void 0 : _c.credentialTest[credential.testedBy])) {
                                        return (_d = versionedNode.methods) === null || _d === void 0 ? void 0 : _d.credentialTest[credential.testedBy];
                                    }
                                }
                            }
                            return (_e = node.methods) === null || _e === void 0 ? void 0 : _e.credentialTest[credential.testedBy];
                        }
                        return {
                            nodeType,
                            testRequest: credential.testedBy,
                        };
                    }
                }
            }
        }
        const type = this.credentialTypes.getByName(credentialType);
        if (type.test) {
            return {
                testRequest: type.test,
            };
        }
        return undefined;
    }
    async testCredentials(user, credentialType, credentialsDecrypted, nodeToTestWith) {
        var _a;
        const credentialTestFunction = this.getCredentialTestFunction(credentialType, nodeToTestWith);
        if (credentialTestFunction === undefined) {
            return Promise.resolve({
                status: 'Error',
                message: 'No testing function found for this credential.',
            });
        }
        if (typeof credentialTestFunction === 'function') {
            const credentialTestFunctions = n8n_core_1.NodeExecuteFunctions.getCredentialTestFunctions();
            return credentialTestFunction.call(credentialTestFunctions, credentialsDecrypted);
        }
        let nodeType;
        if (credentialTestFunction.nodeType) {
            nodeType = credentialTestFunction.nodeType;
        }
        else {
            const nodeTypes = (0, _1.NodeTypes)();
            nodeType = nodeTypes.getByNameAndVersion('n8n-nodes-base.noOp');
        }
        const node = {
            id: 'temp',
            parameters: {},
            name: 'Temp-Node',
            type: nodeType.description.name,
            typeVersion: Array.isArray(nodeType.description.version)
                ? nodeType.description.version.slice(-1)[0]
                : nodeType.description.version,
            position: [0, 0],
            credentials: {
                [credentialType]: {
                    id: credentialsDecrypted.id.toString(),
                    name: credentialsDecrypted.name,
                },
            },
        };
        const workflowData = {
            nodes: [node],
            connections: {},
        };
        const nodeTypeCopy = {
            description: {
                ...nodeType.description,
                credentials: [
                    {
                        name: credentialType,
                        required: true,
                    },
                ],
                properties: [
                    {
                        displayName: 'Temp',
                        name: 'temp',
                        type: 'string',
                        routing: {
                            request: credentialTestFunction.testRequest.request,
                        },
                        default: '',
                    },
                ],
            },
        };
        const nodeTypes = {
            ...mockNodeTypes,
            nodeTypes: {
                [nodeTypeCopy.description.name]: {
                    sourcePath: '',
                    type: nodeTypeCopy,
                },
            },
        };
        const workflow = new n8n_workflow_1.Workflow({
            nodes: workflowData.nodes,
            connections: workflowData.connections,
            active: false,
            nodeTypes,
        });
        const mode = 'internal';
        const runIndex = 0;
        const inputData = {
            main: [[{ json: {} }]],
        };
        const connectionInputData = [];
        const runExecutionData = {
            resultData: {
                runData: {},
            },
        };
        const additionalData = await _1.WorkflowExecuteAdditionalData.getBase(user.id, node.parameters);
        const routingNode = new n8n_workflow_1.RoutingNode(workflow, node, connectionInputData, runExecutionData !== null && runExecutionData !== void 0 ? runExecutionData : null, additionalData, mode);
        let response;
        try {
            response = await routingNode.runNode(inputData, runIndex, nodeTypeCopy, { node, data: {}, source: null }, n8n_core_1.NodeExecuteFunctions, credentialsDecrypted);
        }
        catch (error) {
            if ((_a = error.cause) === null || _a === void 0 ? void 0 : _a.response) {
                const errorResponseData = {
                    statusCode: error.cause.response.status,
                    statusMessage: error.cause.response.statusText,
                };
                if (credentialTestFunction.testRequest.rules) {
                    for (const rule of credentialTestFunction.testRequest.rules) {
                        if (rule.type === 'responseCode') {
                            if (errorResponseData.statusCode === rule.properties.value) {
                                return {
                                    status: 'Error',
                                    message: rule.properties.message,
                                };
                            }
                        }
                    }
                }
                if (errorResponseData.statusCode < 199 || errorResponseData.statusCode > 299) {
                    return {
                        status: 'Error',
                        message: errorResponseData.statusMessage ||
                            `Received HTTP status code: ${errorResponseData.statusCode}`,
                    };
                }
            }
            else if (error.cause.code) {
                return {
                    status: 'Error',
                    message: error.cause.code,
                };
            }
            n8n_workflow_1.LoggerProxy.debug('Credential test failed', error);
            return {
                status: 'Error',
                message: error.message.toString(),
            };
        }
        if (credentialTestFunction.testRequest.rules &&
            Array.isArray(credentialTestFunction.testRequest.rules)) {
            for (const rule of credentialTestFunction.testRequest.rules) {
                if (rule.type === 'responseSuccessBody') {
                    const responseData = response[0][0].json;
                    if ((0, lodash_1.get)(responseData, rule.properties.key) === rule.properties.value) {
                        return {
                            status: 'Error',
                            message: rule.properties.message,
                        };
                    }
                }
            }
        }
        return {
            status: 'OK',
            message: 'Connection successful!',
        };
    }
}
exports.CredentialsHelper = CredentialsHelper;
function whereClause({ user, entityType, entityId = '', }) {
    const where = entityId ? { [entityType]: { id: entityId } } : {};
    if (user.globalRole.name !== 'owner') {
        where.user = { id: user.id };
    }
    return where;
}
exports.whereClause = whereClause;
async function getCredentialForUser(credentialId, user) {
    const sharedCredential = await _1.Db.collections.SharedCredentials.findOne({
        relations: ['credentials'],
        where: whereClause({
            user,
            entityType: 'credentials',
            entityId: credentialId,
        }),
    });
    if (!sharedCredential)
        return null;
    return sharedCredential.credentials;
}
exports.getCredentialForUser = getCredentialForUser;
async function getCredentialWithoutUser(credentialId) {
    const credential = await _1.Db.collections.Credentials.findOne(credentialId);
    return credential;
}
exports.getCredentialWithoutUser = getCredentialWithoutUser;
function createCredentialsFromCredentialsEntity(credential, encrypt = false) {
    const { id, name, type, nodesAccess, data } = credential;
    if (encrypt) {
        return new n8n_core_1.Credentials({ id: null, name }, type, nodesAccess);
    }
    return new n8n_core_1.Credentials({ id: id.toString(), name }, type, nodesAccess, data);
}
exports.createCredentialsFromCredentialsEntity = createCredentialsFromCredentialsEntity;
//# sourceMappingURL=CredentialsHelper.js.map