"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = exports.linkRepository = exports.transaction = exports.collections = exports.isInitialized = void 0;
const n8n_core_1 = require("n8n-core");
const typeorm_1 = require("typeorm");
const path_1 = __importDefault(require("path"));
const _1 = require(".");
const config_1 = __importDefault(require("../config"));
const entities_1 = require("./databases/entities");
const postgresdb_1 = require("./databases/migrations/postgresdb");
const mysqldb_1 = require("./databases/migrations/mysqldb");
const sqlite_1 = require("./databases/migrations/sqlite");
exports.isInitialized = false;
exports.collections = {};
let connection;
async function transaction(fn) {
    return connection.transaction(fn);
}
exports.transaction = transaction;
function linkRepository(entityClass) {
    return (0, typeorm_1.getRepository)(entityClass, connection.name);
}
exports.linkRepository = linkRepository;
async function init(testConnectionOptions) {
    if (exports.isInitialized)
        return exports.collections;
    const dbType = (await _1.GenericHelpers.getConfigValue('database.type'));
    const n8nFolder = n8n_core_1.UserSettings.getUserN8nFolderPath();
    let connectionOptions;
    const entityPrefix = config_1.default.getEnv('database.tablePrefix');
    if (testConnectionOptions) {
        connectionOptions = testConnectionOptions;
    }
    else {
        switch (dbType) {
            case 'postgresdb':
                const sslCa = (await _1.GenericHelpers.getConfigValue('database.postgresdb.ssl.ca'));
                const sslCert = (await _1.GenericHelpers.getConfigValue('database.postgresdb.ssl.cert'));
                const sslKey = (await _1.GenericHelpers.getConfigValue('database.postgresdb.ssl.key'));
                const sslRejectUnauthorized = (await _1.GenericHelpers.getConfigValue('database.postgresdb.ssl.rejectUnauthorized'));
                let ssl;
                if (sslCa !== '' || sslCert !== '' || sslKey !== '' || !sslRejectUnauthorized) {
                    ssl = {
                        ca: sslCa || undefined,
                        cert: sslCert || undefined,
                        key: sslKey || undefined,
                        rejectUnauthorized: sslRejectUnauthorized,
                    };
                }
                connectionOptions = {
                    type: 'postgres',
                    entityPrefix,
                    database: (await _1.GenericHelpers.getConfigValue('database.postgresdb.database')),
                    host: (await _1.GenericHelpers.getConfigValue('database.postgresdb.host')),
                    password: (await _1.GenericHelpers.getConfigValue('database.postgresdb.password')),
                    port: (await _1.GenericHelpers.getConfigValue('database.postgresdb.port')),
                    username: (await _1.GenericHelpers.getConfigValue('database.postgresdb.user')),
                    schema: config_1.default.getEnv('database.postgresdb.schema'),
                    migrations: postgresdb_1.postgresMigrations,
                    migrationsRun: true,
                    migrationsTableName: `${entityPrefix}migrations`,
                    ssl,
                };
                break;
            case 'mariadb':
            case 'mysqldb':
                connectionOptions = {
                    type: dbType === 'mysqldb' ? 'mysql' : 'mariadb',
                    database: (await _1.GenericHelpers.getConfigValue('database.mysqldb.database')),
                    entityPrefix,
                    host: (await _1.GenericHelpers.getConfigValue('database.mysqldb.host')),
                    password: (await _1.GenericHelpers.getConfigValue('database.mysqldb.password')),
                    port: (await _1.GenericHelpers.getConfigValue('database.mysqldb.port')),
                    username: (await _1.GenericHelpers.getConfigValue('database.mysqldb.user')),
                    migrations: mysqldb_1.mysqlMigrations,
                    migrationsRun: true,
                    migrationsTableName: `${entityPrefix}migrations`,
                    timezone: 'Z',
                };
                break;
            case 'sqlite':
                connectionOptions = {
                    type: 'sqlite',
                    database: path_1.default.join(n8nFolder, 'database.sqlite'),
                    entityPrefix,
                    migrations: sqlite_1.sqliteMigrations,
                    migrationsRun: false,
                    migrationsTableName: `${entityPrefix}migrations`,
                };
                break;
            default:
                throw new Error(`The database "${dbType}" is currently not supported!`);
        }
    }
    let loggingOption = (await _1.GenericHelpers.getConfigValue('database.logging.enabled'));
    if (loggingOption) {
        const optionsString = (await _1.GenericHelpers.getConfigValue('database.logging.options')).replace(/\s+/g, '');
        if (optionsString === 'all') {
            loggingOption = optionsString;
        }
        else {
            loggingOption = optionsString.split(',');
        }
    }
    Object.assign(connectionOptions, {
        entities: Object.values(entities_1.entities),
        synchronize: false,
        logging: loggingOption,
        maxQueryExecutionTime: (await _1.GenericHelpers.getConfigValue('database.logging.maxQueryExecutionTime')),
    });
    connection = await (0, typeorm_1.createConnection)(connectionOptions);
    if (!testConnectionOptions && dbType === 'sqlite') {
        let migrations = [];
        try {
            migrations = await connection.query(`SELECT id FROM ${entityPrefix}migrations where name = "MakeStoppedAtNullable1607431743769"`);
        }
        catch (error) {
        }
        await connection.runMigrations({
            transaction: 'none',
        });
        if (migrations.length === 0) {
            await connection.close();
            connection = await (0, typeorm_1.createConnection)(connectionOptions);
        }
    }
    exports.collections.Credentials = linkRepository(entities_1.entities.CredentialsEntity);
    exports.collections.Execution = linkRepository(entities_1.entities.ExecutionEntity);
    exports.collections.Workflow = linkRepository(entities_1.entities.WorkflowEntity);
    exports.collections.Webhook = linkRepository(entities_1.entities.WebhookEntity);
    exports.collections.Tag = linkRepository(entities_1.entities.TagEntity);
    exports.collections.Role = linkRepository(entities_1.entities.Role);
    exports.collections.User = linkRepository(entities_1.entities.User);
    exports.collections.SharedCredentials = linkRepository(entities_1.entities.SharedCredentials);
    exports.collections.SharedWorkflow = linkRepository(entities_1.entities.SharedWorkflow);
    exports.collections.Settings = linkRepository(entities_1.entities.Settings);
    exports.collections.InstalledPackages = linkRepository(entities_1.entities.InstalledPackages);
    exports.collections.InstalledNodes = linkRepository(entities_1.entities.InstalledNodes);
    exports.isInitialized = true;
    return exports.collections;
}
exports.init = init;
//# sourceMappingURL=Db.js.map