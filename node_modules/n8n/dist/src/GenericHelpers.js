"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_EXECUTIONS_GET_ALL_LIMIT = exports.createErrorExecution = exports.validateEntity = exports.generateUniqueName = exports.getConfigValue = exports.getVersions = exports.getSessionId = exports.getBaseUrl = void 0;
const path_1 = require("path");
const promises_1 = require("fs/promises");
const n8n_workflow_1 = require("n8n-workflow");
const class_validator_1 = require("class-validator");
const config_1 = __importDefault(require("../config"));
const _1 = require(".");
const typeorm_1 = require("typeorm");
let versionCache;
function getBaseUrl() {
    const protocol = config_1.default.getEnv('protocol');
    const host = config_1.default.getEnv('host');
    const port = config_1.default.getEnv('port');
    const path = config_1.default.getEnv('path');
    if ((protocol === 'http' && port === 80) || (protocol === 'https' && port === 443)) {
        return `${protocol}://${host}${path}`;
    }
    return `${protocol}://${host}:${port}${path}`;
}
exports.getBaseUrl = getBaseUrl;
function getSessionId(req) {
    return req.headers.sessionid;
}
exports.getSessionId = getSessionId;
async function getVersions() {
    if (versionCache !== undefined) {
        return versionCache;
    }
    const packageFile = await (0, promises_1.readFile)((0, path_1.join)(__dirname, '../../package.json'), 'utf8');
    const packageData = (0, n8n_workflow_1.jsonParse)(packageFile);
    versionCache = {
        cli: packageData.version,
    };
    return versionCache;
}
exports.getVersions = getVersions;
function extractSchemaForKey(configKey, configSchema) {
    const configKeyParts = configKey.split('.');
    for (const key of configKeyParts) {
        if (configSchema[key] === undefined) {
            throw new Error(`Key "${key}" of ConfigKey "${configKey}" does not exist`);
        }
        else if (configSchema[key]._cvtProperties === undefined) {
            configSchema = configSchema[key];
        }
        else {
            configSchema = configSchema[key]._cvtProperties;
        }
    }
    return configSchema;
}
async function getConfigValue(configKey) {
    const configSchema = config_1.default.getSchema();
    const currentSchema = extractSchemaForKey(configKey, configSchema._cvtProperties);
    if (currentSchema.env === undefined) {
        return config_1.default.getEnv(configKey);
    }
    const fileEnvironmentVariable = process.env[`${currentSchema.env}_FILE`];
    if (fileEnvironmentVariable === undefined) {
        return config_1.default.getEnv(configKey);
    }
    let data;
    try {
        data = await (0, promises_1.readFile)(fileEnvironmentVariable, 'utf8');
    }
    catch (error) {
        if (error.code === 'ENOENT') {
            throw new Error(`The file "${fileEnvironmentVariable}" could not be found.`);
        }
        throw error;
    }
    return data;
}
exports.getConfigValue = getConfigValue;
async function generateUniqueName(requestedName, entityType) {
    const findConditions = {
        select: ['name'],
        where: {
            name: (0, typeorm_1.Like)(`${requestedName}%`),
        },
    };
    const found = entityType === 'workflow'
        ? await _1.Db.collections.Workflow.find(findConditions)
        : await _1.Db.collections.Credentials.find(findConditions);
    if (found.length === 0) {
        return requestedName;
    }
    const maxSuffix = found.reduce((acc, { name }) => {
        const parts = name.split(`${requestedName} `);
        if (parts.length > 2)
            return acc;
        const suffix = Number(parts[1]);
        if (!isNaN(suffix) && Math.ceil(suffix) > acc) {
            acc = Math.ceil(suffix);
        }
        return acc;
    }, 0);
    if (maxSuffix === 0) {
        return `${requestedName} 2`;
    }
    return `${requestedName} ${maxSuffix + 1}`;
}
exports.generateUniqueName = generateUniqueName;
async function validateEntity(entity) {
    const errors = await (0, class_validator_1.validate)(entity);
    const errorMessages = errors
        .reduce((acc, cur) => {
        if (!cur.constraints)
            return acc;
        acc.push(...Object.values(cur.constraints));
        return acc;
    }, [])
        .join(' | ');
    if (errorMessages) {
        throw new _1.ResponseHelper.ResponseError(errorMessages, undefined, 400);
    }
}
exports.validateEntity = validateEntity;
async function createErrorExecution(error, node, workflowData, workflow, mode) {
    var _a;
    const saveDataErrorExecutionDisabled = ((_a = workflowData === null || workflowData === void 0 ? void 0 : workflowData.settings) === null || _a === void 0 ? void 0 : _a.saveDataErrorExecution) === 'none';
    if (saveDataErrorExecutionDisabled)
        return;
    const executionData = {
        startData: {
            destinationNode: node.name,
            runNodeFilter: [node.name],
        },
        executionData: {
            contextData: {},
            nodeExecutionStack: [
                {
                    node,
                    data: {
                        main: [
                            [
                                {
                                    json: {},
                                    pairedItem: {
                                        item: 0,
                                    },
                                },
                            ],
                        ],
                    },
                    source: null,
                },
            ],
            waitingExecution: {},
            waitingExecutionSource: {},
        },
        resultData: {
            runData: {
                [node.name]: [
                    {
                        startTime: 0,
                        executionTime: 0,
                        error,
                        source: [],
                    },
                ],
            },
            error,
            lastNodeExecuted: node.name,
        },
    };
    const fullExecutionData = {
        data: executionData,
        mode,
        finished: false,
        startedAt: new Date(),
        workflowData,
        workflowId: workflow.id,
        stoppedAt: new Date(),
    };
    const execution = _1.ResponseHelper.flattenExecutionData(fullExecutionData);
    await _1.Db.collections.Execution.save(execution);
}
exports.createErrorExecution = createErrorExecution;
exports.DEFAULT_EXECUTIONS_GET_ALL_LIMIT = 20;
//# sourceMappingURL=GenericHelpers.js.map