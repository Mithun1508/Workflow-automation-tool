"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalHooksClass = void 0;
const change_case_1 = require("change-case");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const psl_1 = require("psl");
class InternalHooksClass {
    constructor(telemetry, instanceId, versionCli, nodeTypes) {
        this.telemetry = telemetry;
        this.instanceId = instanceId;
        this.versionCli = versionCli;
        this.nodeTypes = nodeTypes;
    }
    async onServerStarted(diagnosticInfo, earliestWorkflowCreatedAt) {
        const info = {
            version_cli: diagnosticInfo.versionCli,
            db_type: diagnosticInfo.databaseType,
            n8n_version_notifications_enabled: diagnosticInfo.notificationsEnabled,
            n8n_disable_production_main_process: diagnosticInfo.disableProductionWebhooksOnMainProcess,
            n8n_basic_auth_active: diagnosticInfo.basicAuthActive,
            system_info: diagnosticInfo.systemInfo,
            execution_variables: diagnosticInfo.executionVariables,
            n8n_deployment_type: diagnosticInfo.deploymentType,
            n8n_binary_data_mode: diagnosticInfo.binaryDataMode,
            n8n_multi_user_allowed: diagnosticInfo.n8n_multi_user_allowed,
            smtp_set_up: diagnosticInfo.smtp_set_up,
        };
        return Promise.all([
            this.telemetry.identify(info),
            this.telemetry.track('Instance started', {
                ...info,
                earliest_workflow_created: earliestWorkflowCreatedAt,
            }),
        ]);
    }
    async onFrontendSettingsAPI(sessionId) {
        return this.telemetry.track('Session started', { session_id: sessionId });
    }
    async onPersonalizationSurveySubmitted(userId, answers) {
        const camelCaseKeys = Object.keys(answers);
        const personalizationSurveyData = { user_id: userId };
        camelCaseKeys.forEach((camelCaseKey) => {
            personalizationSurveyData[(0, change_case_1.snakeCase)(camelCaseKey)] = answers[camelCaseKey];
        });
        return this.telemetry.track('User responded to personalization questions', personalizationSurveyData, { withPostHog: true });
    }
    async onWorkflowCreated(userId, workflow, publicApi) {
        const { nodeGraph } = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow, this.nodeTypes);
        return this.telemetry.track('User created workflow', {
            user_id: userId,
            workflow_id: workflow.id,
            node_graph_string: JSON.stringify(nodeGraph),
            public_api: publicApi,
        });
    }
    async onWorkflowDeleted(userId, workflowId, publicApi) {
        return this.telemetry.track('User deleted workflow', {
            user_id: userId,
            workflow_id: workflowId,
            public_api: publicApi,
        });
    }
    async onWorkflowSaved(userId, workflow, publicApi) {
        var _a, _b;
        const { nodeGraph } = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow, this.nodeTypes);
        const notesCount = Object.keys(nodeGraph.notes).length;
        const overlappingCount = Object.values(nodeGraph.notes).filter((note) => note.overlapping).length;
        return this.telemetry.track('User saved workflow', {
            user_id: userId,
            workflow_id: workflow.id,
            node_graph_string: JSON.stringify(nodeGraph),
            notes_count_overlapping: overlappingCount,
            notes_count_non_overlapping: notesCount - overlappingCount,
            version_cli: this.versionCli,
            num_tags: (_b = (_a = workflow.tags) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,
            public_api: publicApi,
        }, { withPostHog: true });
    }
    async onWorkflowPostExecute(executionId, workflow, runData, userId) {
        var _a, _b, _c, _d, _e, _f;
        const promises = [Promise.resolve()];
        if (!workflow.id) {
            return Promise.resolve();
        }
        const properties = {
            workflow_id: workflow.id.toString(),
            is_manual: false,
            version_cli: this.versionCli,
            success: false,
        };
        if (userId) {
            properties.user_id = userId;
        }
        if (runData !== undefined) {
            properties.execution_mode = runData.mode;
            properties.success = !!runData.finished;
            properties.is_manual = runData.mode === 'manual';
            let nodeGraphResult = null;
            if (!properties.success && (runData === null || runData === void 0 ? void 0 : runData.data.resultData.error)) {
                properties.error_message = runData === null || runData === void 0 ? void 0 : runData.data.resultData.error.message;
                let errorNodeName = 'node' in (runData === null || runData === void 0 ? void 0 : runData.data.resultData.error)
                    ? (_a = runData === null || runData === void 0 ? void 0 : runData.data.resultData.error.node) === null || _a === void 0 ? void 0 : _a.name
                    : undefined;
                properties.error_node_type =
                    'node' in (runData === null || runData === void 0 ? void 0 : runData.data.resultData.error)
                        ? (_b = runData === null || runData === void 0 ? void 0 : runData.data.resultData.error.node) === null || _b === void 0 ? void 0 : _b.type
                        : undefined;
                if (runData.data.resultData.lastNodeExecuted) {
                    const lastNode = n8n_workflow_1.TelemetryHelpers.getNodeTypeForName(workflow, runData.data.resultData.lastNodeExecuted);
                    if (lastNode !== undefined) {
                        properties.error_node_type = lastNode.type;
                        errorNodeName = lastNode.name;
                    }
                }
                if (properties.is_manual) {
                    nodeGraphResult = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow, this.nodeTypes);
                    properties.node_graph = nodeGraphResult.nodeGraph;
                    properties.node_graph_string = JSON.stringify(nodeGraphResult.nodeGraph);
                    if (errorNodeName) {
                        properties.error_node_id = nodeGraphResult.nameIndices[errorNodeName];
                    }
                }
            }
            if (properties.is_manual) {
                if (!nodeGraphResult) {
                    nodeGraphResult = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow, this.nodeTypes);
                }
                const manualExecEventProperties = {
                    user_id: userId,
                    workflow_id: workflow.id.toString(),
                    status: properties.success ? 'success' : 'failed',
                    error_message: properties.error_message,
                    error_node_type: properties.error_node_type,
                    node_graph_string: properties.node_graph_string,
                    error_node_id: properties.error_node_id,
                    webhook_domain: null,
                };
                if (!manualExecEventProperties.node_graph_string) {
                    nodeGraphResult = n8n_workflow_1.TelemetryHelpers.generateNodesGraph(workflow, this.nodeTypes);
                    manualExecEventProperties.node_graph_string = JSON.stringify(nodeGraphResult.nodeGraph);
                }
                if ((_c = runData.data.startData) === null || _c === void 0 ? void 0 : _c.destinationNode) {
                    const telemetryPayload = {
                        ...manualExecEventProperties,
                        node_type: (_e = n8n_workflow_1.TelemetryHelpers.getNodeTypeForName(workflow, (_d = runData.data.startData) === null || _d === void 0 ? void 0 : _d.destinationNode)) === null || _e === void 0 ? void 0 : _e.type,
                        node_id: nodeGraphResult.nameIndices[(_f = runData.data.startData) === null || _f === void 0 ? void 0 : _f.destinationNode],
                    };
                    promises.push(this.telemetry.track('Manual node exec finished', telemetryPayload, {
                        withPostHog: true,
                    }));
                }
                else {
                    nodeGraphResult.webhookNodeNames.forEach((name) => {
                        var _a, _b, _c, _d, _e, _f, _g;
                        const execJson = (_f = (_e = (_d = (_c = (_b = (_a = runData.data.resultData.runData[name]) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.main) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.json;
                        if (((_g = execJson === null || execJson === void 0 ? void 0 : execJson.headers) === null || _g === void 0 ? void 0 : _g.origin) && execJson.headers.origin !== '') {
                            manualExecEventProperties.webhook_domain = (0, psl_1.get)(execJson.headers.origin.replace(/^https?:\/\//, ''));
                        }
                    });
                    promises.push(this.telemetry.track('Manual workflow exec finished', manualExecEventProperties, {
                        withPostHog: true,
                    }));
                }
            }
        }
        return Promise.all([
            ...promises,
            n8n_core_1.BinaryDataManager.getInstance().persistBinaryDataForExecutionId(executionId),
            this.telemetry.trackWorkflowExecution(properties),
        ]).then(() => { });
    }
    async onN8nStop() {
        const timeoutPromise = new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, 3000);
        });
        return Promise.race([timeoutPromise, this.telemetry.trackN8nStop()]);
    }
    async onUserDeletion(userId, userDeletionData, publicApi) {
        return this.telemetry.track('User deleted user', {
            ...userDeletionData,
            user_id: userId,
            public_api: publicApi,
        });
    }
    async onUserInvite(userInviteData) {
        return this.telemetry.track('User invited new user', userInviteData);
    }
    async onUserReinvite(userReinviteData) {
        return this.telemetry.track('User resent new user invite email', userReinviteData);
    }
    async onUserRetrievedUser(userRetrievedData) {
        return this.telemetry.track('User retrieved user', userRetrievedData);
    }
    async onUserRetrievedAllUsers(userRetrievedData) {
        return this.telemetry.track('User retrieved all users', userRetrievedData);
    }
    async onUserRetrievedExecution(userRetrievedData) {
        return this.telemetry.track('User retrieved execution', userRetrievedData);
    }
    async onUserRetrievedAllExecutions(userRetrievedData) {
        return this.telemetry.track('User retrieved all executions', userRetrievedData);
    }
    async onUserRetrievedWorkflow(userRetrievedData) {
        return this.telemetry.track('User retrieved workflow', userRetrievedData);
    }
    async onUserRetrievedAllWorkflows(userRetrievedData) {
        return this.telemetry.track('User retrieved all workflows', userRetrievedData);
    }
    async onUserUpdate(userUpdateData) {
        return this.telemetry.track('User changed personal settings', userUpdateData);
    }
    async onUserInviteEmailClick(userInviteClickData) {
        return this.telemetry.track('User clicked invite link from email', userInviteClickData);
    }
    async onUserPasswordResetEmailClick(userPasswordResetData) {
        return this.telemetry.track('User clicked password reset link from email', userPasswordResetData);
    }
    async onUserTransactionalEmail(userTransactionalEmailData) {
        return this.telemetry.track('Instance sent transactional email to user', userTransactionalEmailData);
    }
    async onUserInvokedApi(userInvokedApiData) {
        return this.telemetry.track('User invoked API', userInvokedApiData);
    }
    async onApiKeyDeleted(apiKeyDeletedData) {
        return this.telemetry.track('API key deleted', apiKeyDeletedData);
    }
    async onApiKeyCreated(apiKeyCreatedData) {
        return this.telemetry.track('API key created', apiKeyCreatedData);
    }
    async onUserPasswordResetRequestClick(userPasswordResetData) {
        return this.telemetry.track('User requested password reset while logged out', userPasswordResetData);
    }
    async onInstanceOwnerSetup(instanceOwnerSetupData) {
        return this.telemetry.track('Owner finished instance setup', instanceOwnerSetupData);
    }
    async onUserSignup(userSignupData) {
        return this.telemetry.track('User signed up', userSignupData);
    }
    async onEmailFailed(failedEmailData) {
        return this.telemetry.track('Instance failed to send transactional email to user', failedEmailData);
    }
    async onUserCreatedCredentials(userCreatedCredentialsData) {
        return this.telemetry.track('User created credentials', {
            ...userCreatedCredentialsData,
            instance_id: this.instanceId,
        });
    }
    async onUserSharedCredentials(userSharedCredentialsData) {
        return this.telemetry.track('User updated cred sharing', {
            ...userSharedCredentialsData,
            instance_id: this.instanceId,
        });
    }
    async onCommunityPackageInstallFinished(installationData) {
        return this.telemetry.track('cnr package install finished', installationData);
    }
    async onCommunityPackageUpdateFinished(updateData) {
        return this.telemetry.track('cnr package updated', updateData);
    }
    async onCommunityPackageDeleteFinished(updateData) {
        return this.telemetry.track('cnr package deleted', updateData);
    }
}
exports.InternalHooksClass = InternalHooksClass;
//# sourceMappingURL=InternalHooks.js.map