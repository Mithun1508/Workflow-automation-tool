"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoadNodesAndCredentials = void 0;
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const promises_1 = require("fs/promises");
const fast_glob_1 = __importDefault(require("fast-glob"));
const path_1 = __importDefault(require("path"));
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const Logger_1 = require("./Logger");
const config_1 = __importDefault(require("../config"));
const _1 = require(".");
const helpers_1 = require("./CommunityNodes/helpers");
const constants_1 = require("./constants");
const packageModel_1 = require("./CommunityNodes/packageModel");
const CUSTOM_NODES_CATEGORY = 'Custom Nodes';
function toJSON() {
    return {
        ...this,
        authenticate: typeof this.authenticate === 'function' ? {} : this.authenticate,
    };
}
class LoadNodesAndCredentialsClass {
    constructor() {
        this.nodeTypes = {};
        this.credentialTypes = {};
        this.excludeNodes = undefined;
        this.includeNodes = undefined;
        this.nodeModulesPath = '';
    }
    async init() {
        this.logger = (0, Logger_1.getLogger)();
        n8n_workflow_1.LoggerProxy.init(this.logger);
        const delimiter = process.platform === 'win32' ? ';' : ':';
        process.env.NODE_PATH = module.paths.join(delimiter);
        module.constructor._initPaths();
        this.nodeModulesPath = await this.getNodeModulesFolderLocation();
        this.excludeNodes = config_1.default.getEnv('nodes.exclude');
        this.includeNodes = config_1.default.getEnv('nodes.include');
        const nodePackages = await this.getN8nNodePackages(this.nodeModulesPath);
        for (const packagePath of nodePackages) {
            await this.loadDataFromPackage(packagePath);
        }
        await this.loadNodesFromDownloadedPackages();
        await this.loadNodesFromCustomFolders();
    }
    async getNodeModulesFolderLocation() {
        const checkPaths = [
            path_1.default.join(__dirname, '..', '..', '..', 'n8n-workflow'),
            path_1.default.join(__dirname, '..', '..', 'node_modules', 'n8n-workflow'),
            path_1.default.join(__dirname, '..', '..', '..', '..', 'node_modules', 'n8n-workflow'),
        ];
        for (const checkPath of checkPaths) {
            try {
                await (0, promises_1.access)(checkPath);
                return path_1.default.dirname(checkPath);
            }
            catch (_) {
            }
        }
        throw new Error('Could not find "node_modules" folder!');
    }
    async loadNodesFromDownloadedPackages() {
        const nodePackages = [];
        try {
            const downloadedNodesFolder = n8n_core_1.UserSettings.getUserN8nFolderDowloadedNodesPath();
            const downloadedNodesFolderModules = path_1.default.join(downloadedNodesFolder, 'node_modules');
            await (0, promises_1.access)(downloadedNodesFolderModules);
            const downloadedPackages = await this.getN8nNodePackages(downloadedNodesFolderModules);
            nodePackages.push(...downloadedPackages);
        }
        catch (error) { }
        for (const packagePath of nodePackages) {
            try {
                await this.loadDataFromPackage(packagePath);
            }
            catch (error) { }
        }
    }
    async loadNodesFromCustomFolders() {
        const customDirectories = [];
        customDirectories.push(n8n_core_1.UserSettings.getUserN8nFolderCustomExtensionPath());
        if (process.env[n8n_core_1.CUSTOM_EXTENSION_ENV] !== undefined) {
            const customExtensionFolders = process.env[n8n_core_1.CUSTOM_EXTENSION_ENV].split(';');
            customDirectories.push(...customExtensionFolders);
        }
        for (const directory of customDirectories) {
            await this.loadDataFromDirectory('CUSTOM', directory);
        }
    }
    async getN8nNodePackages(baseModulesPath) {
        const getN8nNodePackagesRecursive = async (relativePath) => {
            const results = [];
            const nodeModulesPath = `${baseModulesPath}/${relativePath}`;
            for (const file of await (0, promises_1.readdir)(nodeModulesPath)) {
                const isN8nNodesPackage = file.indexOf('n8n-nodes-') === 0;
                const isNpmScopedPackage = file.indexOf('@') === 0;
                if (!isN8nNodesPackage && !isNpmScopedPackage) {
                    continue;
                }
                if (!(await (0, promises_1.stat)(nodeModulesPath)).isDirectory()) {
                    continue;
                }
                if (isN8nNodesPackage) {
                    results.push(`${baseModulesPath}/${relativePath}${file}`);
                }
                if (isNpmScopedPackage) {
                    results.push(...(await getN8nNodePackagesRecursive(`${relativePath}${file}/`)));
                }
            }
            return results;
        };
        return getN8nNodePackagesRecursive('');
    }
    loadCredentialsFromFile(credentialName, filePath) {
        let tempCredential;
        try {
            tempCredential = (0, helpers_1.loadClassInIsolation)(filePath, credentialName);
            Object.assign(tempCredential, { toJSON });
            if (tempCredential.icon && tempCredential.icon.startsWith('file:')) {
                tempCredential.icon = `file:${path_1.default.join(path_1.default.dirname(filePath), tempCredential.icon.substr(5))}`;
            }
        }
        catch (e) {
            if (e instanceof TypeError) {
                throw new Error(`Class with name "${credentialName}" could not be found. Please check if the class is named correctly!`);
            }
            else {
                throw e;
            }
        }
        this.credentialTypes[tempCredential.name] = {
            type: tempCredential,
            sourcePath: filePath,
        };
    }
    async loadNpmModule(packageName, version) {
        var _a, _b;
        const downloadFolder = n8n_core_1.UserSettings.getUserN8nFolderDowloadedNodesPath();
        const command = `npm install ${packageName}${version ? `@${version}` : ''}`;
        await (0, helpers_1.executeCommand)(command);
        const finalNodeUnpackedPath = path_1.default.join(downloadFolder, 'node_modules', packageName);
        const loadedNodes = await this.loadDataFromPackage(finalNodeUnpackedPath);
        if (loadedNodes.length > 0) {
            const packageFile = await this.readPackageJson(finalNodeUnpackedPath);
            try {
                const installedPackage = await (0, packageModel_1.persistInstalledPackageData)(packageFile.name, packageFile.version, loadedNodes, this.nodeTypes, (_a = packageFile.author) === null || _a === void 0 ? void 0 : _a.name, (_b = packageFile.author) === null || _b === void 0 ? void 0 : _b.email);
                this.attachNodesToNodeTypes(installedPackage.installedNodes);
                return installedPackage;
            }
            catch (error) {
                n8n_workflow_1.LoggerProxy.error('Failed to save installed packages and nodes', { error, packageName });
                throw error;
            }
        }
        else {
            const removeCommand = `npm remove ${packageName}`;
            try {
                await (0, helpers_1.executeCommand)(removeCommand);
            }
            catch (error) {
            }
            throw new Error(constants_1.RESPONSE_ERROR_MESSAGES.PACKAGE_DOES_NOT_CONTAIN_NODES);
        }
    }
    async removeNpmModule(packageName, installedPackage) {
        const command = `npm remove ${packageName}`;
        await (0, helpers_1.executeCommand)(command);
        void (await (0, packageModel_1.removePackageFromDatabase)(installedPackage));
        this.unloadNodes(installedPackage.installedNodes);
    }
    async updateNpmModule(packageName, installedPackage) {
        var _a, _b;
        const downloadFolder = n8n_core_1.UserSettings.getUserN8nFolderDowloadedNodesPath();
        const command = `npm i ${packageName}@latest`;
        try {
            await (0, helpers_1.executeCommand)(command);
        }
        catch (error) {
            if (error.message === constants_1.RESPONSE_ERROR_MESSAGES.PACKAGE_NOT_FOUND) {
                throw new Error(`The npm package "${packageName}" could not be found.`);
            }
            throw error;
        }
        this.unloadNodes(installedPackage.installedNodes);
        const finalNodeUnpackedPath = path_1.default.join(downloadFolder, 'node_modules', packageName);
        const loadedNodes = await this.loadDataFromPackage(finalNodeUnpackedPath);
        if (loadedNodes.length > 0) {
            const packageFile = await this.readPackageJson(finalNodeUnpackedPath);
            try {
                await (0, packageModel_1.removePackageFromDatabase)(installedPackage);
                const newlyInstalledPackage = await (0, packageModel_1.persistInstalledPackageData)(packageFile.name, packageFile.version, loadedNodes, this.nodeTypes, (_a = packageFile.author) === null || _a === void 0 ? void 0 : _a.name, (_b = packageFile.author) === null || _b === void 0 ? void 0 : _b.email);
                this.attachNodesToNodeTypes(newlyInstalledPackage.installedNodes);
                return newlyInstalledPackage;
            }
            catch (error) {
                n8n_workflow_1.LoggerProxy.error('Failed to save installed packages and nodes', { error, packageName });
                throw error;
            }
        }
        else {
            const removeCommand = `npm remove ${packageName}`;
            try {
                await (0, helpers_1.executeCommand)(removeCommand);
            }
            catch (error) {
            }
            throw new Error(constants_1.RESPONSE_ERROR_MESSAGES.PACKAGE_DOES_NOT_CONTAIN_NODES);
        }
    }
    loadNodeFromFile(packageName, nodeName, filePath) {
        let tempNode;
        let nodeVersion = 1;
        try {
            tempNode = (0, helpers_1.loadClassInIsolation)(filePath, nodeName);
            this.addCodex({ node: tempNode, filePath, isCustom: packageName === 'CUSTOM' });
        }
        catch (error) {
            console.error(`Error loading node "${nodeName}" from: "${filePath}" - ${error.message}`);
            throw error;
        }
        const fullNodeName = `${packageName}.${tempNode.description.name}`;
        tempNode.description.name = fullNodeName;
        if (tempNode.description.icon !== undefined && tempNode.description.icon.startsWith('file:')) {
            tempNode.description.icon = `file:${path_1.default.join(path_1.default.dirname(filePath), tempNode.description.icon.substr(5))}`;
        }
        if (tempNode.hasOwnProperty('nodeVersions')) {
            const versionedNodeType = tempNode.getNodeType();
            this.addCodex({ node: versionedNodeType, filePath, isCustom: packageName === 'CUSTOM' });
            nodeVersion = tempNode.currentVersion;
            if (versionedNodeType.description.icon !== undefined &&
                versionedNodeType.description.icon.startsWith('file:')) {
                versionedNodeType.description.icon = `file:${path_1.default.join(path_1.default.dirname(filePath), versionedNodeType.description.icon.substr(5))}`;
            }
            if (versionedNodeType.hasOwnProperty('executeSingle')) {
                this.logger.warn(`"executeSingle" will get deprecated soon. Please update the code of node "${packageName}.${nodeName}" to use "execute" instead!`, { filePath });
            }
        }
        else {
            const tmpNode = tempNode;
            nodeVersion = Array.isArray(tmpNode.description.version)
                ? tmpNode.description.version.slice(-1)[0]
                : tmpNode.description.version;
        }
        if (this.includeNodes !== undefined && !this.includeNodes.includes(fullNodeName)) {
            return;
        }
        if (this.excludeNodes !== undefined && this.excludeNodes.includes(fullNodeName)) {
            return;
        }
        this.nodeTypes[fullNodeName] = {
            type: tempNode,
            sourcePath: filePath,
        };
        return {
            name: fullNodeName,
            version: nodeVersion,
        };
    }
    getCodex(filePath) {
        const { categories, subcategories, resources: allResources, alias } = require(`${filePath}on`);
        const resources = (0, lodash_pick_1.default)(allResources, ['primaryDocumentation', 'credentialDocumentation']);
        return {
            ...(categories && { categories }),
            ...(subcategories && { subcategories }),
            ...(resources && { resources }),
            ...(alias && { alias }),
        };
    }
    addCodex({ node, filePath, isCustom, }) {
        var _a;
        try {
            const codex = this.getCodex(filePath);
            if (isCustom) {
                codex.categories = codex.categories
                    ? codex.categories.concat(CUSTOM_NODES_CATEGORY)
                    : [CUSTOM_NODES_CATEGORY];
            }
            node.description.codex = codex;
        }
        catch (_) {
            this.logger.debug(`No codex available for: ${(_a = filePath.split('/').pop()) !== null && _a !== void 0 ? _a : ''}`);
            if (isCustom) {
                node.description.codex = {
                    categories: [CUSTOM_NODES_CATEGORY],
                };
            }
        }
    }
    async loadDataFromDirectory(setPackageName, directory) {
        const files = await (0, fast_glob_1.default)('**/*.@(node|credentials).js', {
            cwd: directory,
            absolute: true,
        });
        for (const filePath of files) {
            const [fileName, type] = path_1.default.parse(filePath).name.split('.');
            if (type === 'node') {
                this.loadNodeFromFile(setPackageName, fileName, filePath);
            }
            else if (type === 'credentials') {
                this.loadCredentialsFromFile(fileName, filePath);
            }
        }
    }
    async readPackageJson(packagePath) {
        const packageFileString = await (0, promises_1.readFile)(path_1.default.join(packagePath, 'package.json'), 'utf8');
        return (0, n8n_workflow_1.jsonParse)(packageFileString);
    }
    async loadDataFromPackage(packagePath) {
        const packageFile = await this.readPackageJson(packagePath);
        if (!packageFile.n8n) {
            return [];
        }
        const packageName = packageFile.name;
        const { nodes, credentials } = packageFile.n8n;
        const returnData = [];
        if (Array.isArray(nodes)) {
            for (const filePath of nodes) {
                const tempPath = path_1.default.join(packagePath, filePath);
                const [fileName] = path_1.default.parse(filePath).name.split('.');
                const loadData = this.loadNodeFromFile(packageName, fileName, tempPath);
                if (loadData) {
                    returnData.push(loadData);
                }
            }
        }
        if (Array.isArray(credentials)) {
            for (const filePath of credentials) {
                const tempPath = path_1.default.join(packagePath, filePath);
                const [fileName] = path_1.default.parse(filePath).name.split('.');
                this.loadCredentialsFromFile(fileName, tempPath);
            }
        }
        return returnData;
    }
    unloadNodes(installedNodes) {
        const nodeTypes = (0, _1.NodeTypes)();
        installedNodes.forEach((installedNode) => {
            nodeTypes.removeNodeType(installedNode.type);
            delete this.nodeTypes[installedNode.type];
        });
    }
    attachNodesToNodeTypes(installedNodes) {
        const nodeTypes = (0, _1.NodeTypes)();
        installedNodes.forEach((installedNode) => {
            nodeTypes.attachNodeType(installedNode.type, this.nodeTypes[installedNode.type].type, this.nodeTypes[installedNode.type].sourcePath);
        });
    }
}
let packagesInformationInstance;
function LoadNodesAndCredentials() {
    if (packagesInformationInstance === undefined) {
        packagesInformationInstance = new LoadNodesAndCredentialsClass();
    }
    return packagesInformationInstance;
}
exports.LoadNodesAndCredentials = LoadNodesAndCredentials;
//# sourceMappingURL=LoadNodesAndCredentials.js.map