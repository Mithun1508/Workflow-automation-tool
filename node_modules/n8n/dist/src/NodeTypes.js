"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeTypes = void 0;
const n8n_workflow_1 = require("n8n-workflow");
class NodeTypesClass {
    constructor() {
        this.nodeTypes = {};
    }
    async init(nodeTypes) {
        for (const nodeTypeData of Object.values(nodeTypes)) {
            const nodeType = n8n_workflow_1.NodeHelpers.getVersionedNodeType(nodeTypeData.type);
            const applyParameters = n8n_workflow_1.NodeHelpers.getSpecialNodeParameters(nodeType);
            if (applyParameters.length) {
                nodeType.description.properties.unshift(...applyParameters);
            }
        }
        this.nodeTypes = nodeTypes;
    }
    getAll() {
        return Object.values(this.nodeTypes).map((data) => data.type);
    }
    getWithSourcePath(nodeTypeName, version) {
        const nodeType = this.nodeTypes[nodeTypeName];
        if (!nodeType) {
            throw new Error(`Unknown node type: ${nodeTypeName}`);
        }
        const { description } = n8n_workflow_1.NodeHelpers.getVersionedNodeType(nodeType.type, version);
        return { description: { ...description }, sourcePath: nodeType.sourcePath };
    }
    getByNameAndVersion(nodeType, version) {
        if (this.nodeTypes[nodeType] === undefined) {
            throw new Error(`The node-type "${nodeType}" is not known!`);
        }
        return n8n_workflow_1.NodeHelpers.getVersionedNodeType(this.nodeTypes[nodeType].type, version);
    }
    attachNodeType(nodeTypeName, nodeType, sourcePath) {
        this.nodeTypes[nodeTypeName] = {
            type: nodeType,
            sourcePath,
        };
    }
    removeNodeType(nodeType) {
        delete this.nodeTypes[nodeType];
    }
}
let nodeTypesInstance;
function NodeTypes() {
    if (nodeTypesInstance === undefined) {
        nodeTypesInstance = new NodeTypesClass();
    }
    return nodeTypesInstance;
}
exports.NodeTypes = NodeTypes;
//# sourceMappingURL=NodeTypes.js.map