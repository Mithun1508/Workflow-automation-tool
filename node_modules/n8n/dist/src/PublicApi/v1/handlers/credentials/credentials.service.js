"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toJsonSchema = exports.sanitizeCredentials = exports.encryptCredential = exports.removeCredential = exports.saveCredential = exports.createCredential = exports.getSharedCredentials = exports.getCredentials = void 0;
const n8n_core_1 = require("n8n-core");
const __1 = require("../../../..");
const CredentialsEntity_1 = require("../../../../databases/entities/CredentialsEntity");
const SharedCredentials_1 = require("../../../../databases/entities/SharedCredentials");
const Server_1 = require("../../../../Server");
async function getCredentials(credentialId) {
    return __1.Db.collections.Credentials.findOne(credentialId);
}
exports.getCredentials = getCredentials;
async function getSharedCredentials(userId, credentialId, relations) {
    const options = {
        where: {
            user: { id: userId },
            credentials: { id: credentialId },
        },
    };
    if (relations) {
        options.relations = relations;
    }
    return __1.Db.collections.SharedCredentials.findOne(options);
}
exports.getSharedCredentials = getSharedCredentials;
async function createCredential(properties) {
    var _a, _b;
    const newCredential = new CredentialsEntity_1.CredentialsEntity();
    Object.assign(newCredential, properties);
    if (!newCredential.nodesAccess || newCredential.nodesAccess.length === 0) {
        newCredential.nodesAccess = [
            {
                nodeType: `n8n-nodes-base.${(_b = (_a = properties.type) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : 'unknown'}`,
                date: new Date(),
            },
        ];
    }
    else {
        newCredential.nodesAccess.forEach((nodeAccess) => {
            nodeAccess.date = new Date();
        });
    }
    return newCredential;
}
exports.createCredential = createCredential;
async function saveCredential(credential, user, encryptedData) {
    const role = await __1.Db.collections.Role.findOneOrFail({
        name: 'owner',
        scope: 'credential',
    });
    await Server_1.externalHooks.run('credentials.create', [encryptedData]);
    return __1.Db.transaction(async (transactionManager) => {
        const savedCredential = await transactionManager.save(credential);
        savedCredential.data = credential.data;
        const newSharedCredential = new SharedCredentials_1.SharedCredentials();
        Object.assign(newSharedCredential, {
            role,
            user,
            credentials: savedCredential,
        });
        await transactionManager.save(newSharedCredential);
        return savedCredential;
    });
}
exports.saveCredential = saveCredential;
async function removeCredential(credentials) {
    await Server_1.externalHooks.run('credentials.delete', [credentials.id]);
    return __1.Db.collections.Credentials.remove(credentials);
}
exports.removeCredential = removeCredential;
async function encryptCredential(credential) {
    const encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
    const coreCredential = new n8n_core_1.Credentials({ id: null, name: credential.name }, credential.type, credential.nodesAccess);
    coreCredential.setData(credential.data, encryptionKey);
    return coreCredential.getDataToSave();
}
exports.encryptCredential = encryptCredential;
function sanitizeCredentials(credentials) {
    const argIsArray = Array.isArray(credentials);
    const credentialsList = argIsArray ? credentials : [credentials];
    const sanitizedCredentials = credentialsList.map((credential) => {
        const { data, nodesAccess, shared, ...rest } = credential;
        return rest;
    });
    return argIsArray ? sanitizedCredentials : sanitizedCredentials[0];
}
exports.sanitizeCredentials = sanitizeCredentials;
function toJsonSchema(properties) {
    const jsonSchema = {
        additionalProperties: false,
        type: 'object',
        properties: {},
        allOf: [],
        required: [],
    };
    const optionsValues = {};
    const resolveProperties = [];
    properties
        .filter((property) => property.type === 'options')
        .forEach((property) => {
        var _a;
        Object.assign(optionsValues, {
            [property.name]: (_a = property.options) === null || _a === void 0 ? void 0 : _a.map((option) => option.value),
        });
    });
    let requiredFields = [];
    const propertyRequiredDependencies = {};
    properties.forEach((property) => {
        var _a, _b, _c, _d, _e;
        requiredFields.push(property.name);
        if (property.type === 'options') {
            Object.assign(jsonSchema.properties, {
                [property.name]: {
                    type: 'string',
                    enum: (_a = property.options) === null || _a === void 0 ? void 0 : _a.map((data) => data.value),
                },
            });
        }
        else {
            Object.assign(jsonSchema.properties, {
                [property.name]: {
                    type: property.type,
                },
            });
        }
        if ((_b = property.displayOptions) === null || _b === void 0 ? void 0 : _b.show) {
            const dependantName = Object.keys((_c = property.displayOptions) === null || _c === void 0 ? void 0 : _c.show)[0] || '';
            const displayOptionsValues = property.displayOptions.show[dependantName];
            let dependantValue = '';
            if (displayOptionsValues && Array.isArray(displayOptionsValues) && displayOptionsValues[0]) {
                dependantValue = displayOptionsValues[0];
            }
            if (propertyRequiredDependencies[dependantName] === undefined) {
                propertyRequiredDependencies[dependantName] = {};
            }
            if (!resolveProperties.includes(dependantName)) {
                propertyRequiredDependencies[dependantName] = {
                    if: {
                        properties: {
                            [dependantName]: {
                                enum: [dependantValue],
                            },
                        },
                    },
                    then: {
                        allOf: [],
                    },
                    else: {
                        allOf: [],
                    },
                };
            }
            (_d = propertyRequiredDependencies[dependantName].then) === null || _d === void 0 ? void 0 : _d.allOf.push({ required: [property.name] });
            (_e = propertyRequiredDependencies[dependantName].else) === null || _e === void 0 ? void 0 : _e.allOf.push({
                not: { required: [property.name] },
            });
            resolveProperties.push(dependantName);
            requiredFields = requiredFields.filter((field) => field !== property.name);
        }
    });
    Object.assign(jsonSchema, { required: requiredFields });
    jsonSchema.allOf = Object.values(propertyRequiredDependencies);
    if (!jsonSchema.allOf.length) {
        delete jsonSchema.allOf;
    }
    return jsonSchema;
}
exports.toJsonSchema = toJsonSchema;
//# sourceMappingURL=credentials.service.js.map