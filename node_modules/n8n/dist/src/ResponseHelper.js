"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenObject = exports.unflattenExecutionData = exports.flattenExecutionData = exports.send = exports.sendErrorResponse = exports.sendSuccessResponse = exports.jwtAuthAuthorizationError = exports.basicAuthAuthorizationError = exports.ResponseError = void 0;
const flatted_1 = require("flatted");
class ResponseError extends Error {
    constructor(message, errorCode, httpStatusCode, hint) {
        super(message);
        this.name = 'ResponseError';
        if (errorCode) {
            this.errorCode = errorCode;
        }
        if (httpStatusCode) {
            this.httpStatusCode = httpStatusCode;
        }
        if (hint) {
            this.hint = hint;
        }
    }
}
exports.ResponseError = ResponseError;
function basicAuthAuthorizationError(resp, realm, message) {
    resp.statusCode = 401;
    resp.setHeader('WWW-Authenticate', `Basic realm="${realm}"`);
    resp.json({ code: resp.statusCode, message });
}
exports.basicAuthAuthorizationError = basicAuthAuthorizationError;
function jwtAuthAuthorizationError(resp, message) {
    resp.statusCode = 403;
    resp.json({ code: resp.statusCode, message });
}
exports.jwtAuthAuthorizationError = jwtAuthAuthorizationError;
function sendSuccessResponse(res, data, raw, responseCode, responseHeader) {
    if (responseCode !== undefined) {
        res.status(responseCode);
    }
    if (responseHeader) {
        res.header(responseHeader);
    }
    if (raw === true) {
        if (typeof data === 'string') {
            res.send(data);
        }
        else {
            res.json(data);
        }
    }
    else {
        res.json({
            data,
        });
    }
}
exports.sendSuccessResponse = sendSuccessResponse;
function sendErrorResponse(res, error) {
    let httpStatusCode = 500;
    if (error.httpStatusCode) {
        httpStatusCode = error.httpStatusCode;
    }
    if (!process.env.NODE_ENV || process.env.NODE_ENV === 'development') {
        console.error('ERROR RESPONSE');
        console.error(error);
    }
    const response = {
        code: 0,
        message: 'Unknown error',
        hint: '',
    };
    if (error.name === 'NodeApiError') {
        Object.assign(response, error);
    }
    if (error.errorCode) {
        response.code = error.errorCode;
    }
    if (error.message) {
        response.message = error.message;
    }
    if (error.hint) {
        response.hint = error.hint;
    }
    if (error.stack && process.env.NODE_ENV !== 'production') {
        response.stack = error.stack;
    }
    res.status(httpStatusCode).json(response);
}
exports.sendErrorResponse = sendErrorResponse;
const isUniqueConstraintError = (error) => ['unique', 'duplicate'].some((s) => error.message.toLowerCase().includes(s));
function send(processFunction, raw = false) {
    return async (req, res) => {
        try {
            const data = await processFunction(req, res);
            sendSuccessResponse(res, data, raw);
        }
        catch (error) {
            if (error instanceof Error && isUniqueConstraintError(error)) {
                error.message = 'There is already an entry with this name';
            }
            sendErrorResponse(res, error);
        }
    };
}
exports.send = send;
function flattenExecutionData(fullExecutionData) {
    const returnData = {
        data: (0, flatted_1.stringify)(fullExecutionData.data),
        mode: fullExecutionData.mode,
        waitTill: fullExecutionData.waitTill,
        startedAt: fullExecutionData.startedAt,
        stoppedAt: fullExecutionData.stoppedAt,
        finished: fullExecutionData.finished ? fullExecutionData.finished : false,
        workflowId: fullExecutionData.workflowId,
        workflowData: fullExecutionData.workflowData,
    };
    if (fullExecutionData.id !== undefined) {
        returnData.id = fullExecutionData.id.toString();
    }
    if (fullExecutionData.retryOf !== undefined) {
        returnData.retryOf = fullExecutionData.retryOf.toString();
    }
    if (fullExecutionData.retrySuccessId !== undefined) {
        returnData.retrySuccessId = fullExecutionData.retrySuccessId.toString();
    }
    return returnData;
}
exports.flattenExecutionData = flattenExecutionData;
function unflattenExecutionData(fullExecutionData) {
    const returnData = {
        id: fullExecutionData.id.toString(),
        workflowData: fullExecutionData.workflowData,
        data: (0, flatted_1.parse)(fullExecutionData.data),
        mode: fullExecutionData.mode,
        waitTill: fullExecutionData.waitTill ? fullExecutionData.waitTill : undefined,
        startedAt: fullExecutionData.startedAt,
        stoppedAt: fullExecutionData.stoppedAt,
        finished: fullExecutionData.finished ? fullExecutionData.finished : false,
        workflowId: fullExecutionData.workflowId,
    };
    return returnData;
}
exports.unflattenExecutionData = unflattenExecutionData;
const flattenObject = (obj, prefix = '') => Object.keys(obj).reduce((acc, k) => {
    const pre = prefix.length ? prefix + '.' : '';
    if (typeof obj[k] === 'object')
        Object.assign(acc, (0, exports.flattenObject)(obj[k], pre + k));
    else
        acc[pre + k] = obj[k];
    return acc;
}, {});
exports.flattenObject = flattenObject;
//# sourceMappingURL=ResponseHelper.js.map