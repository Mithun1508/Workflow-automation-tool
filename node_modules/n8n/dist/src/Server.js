"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = exports.externalHooks = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const os_1 = __importDefault(require("os"));
const path_1 = require("path");
const crypto_1 = require("crypto");
const util_1 = require("util");
const cookie_parser_1 = __importDefault(require("cookie-parser"));
const express_1 = __importDefault(require("express"));
const typeorm_1 = require("typeorm");
const axios_1 = __importDefault(require("axios"));
const oauth_1_0a_1 = __importDefault(require("oauth-1.0a"));
const bcryptjs_1 = require("bcryptjs");
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const basic_auth_1 = __importDefault(require("basic-auth"));
const compression_1 = __importDefault(require("compression"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const jwks_rsa_1 = __importDefault(require("jwks-rsa"));
const google_timezones_json_1 = __importDefault(require("google-timezones-json"));
const parseurl_1 = __importDefault(require("parseurl"));
const prom_client_1 = __importDefault(require("prom-client"));
const connect_history_api_fallback_1 = __importDefault(require("connect-history-api-fallback"));
const body_parser_1 = __importDefault(require("body-parser"));
const config_1 = __importDefault(require("../config"));
const Queue = __importStar(require("./Queue"));
const InternalHooksManager_1 = require("./InternalHooksManager");
const TranslationHelpers_1 = require("./TranslationHelpers");
const WebhookHelpers_1 = require("./WebhookHelpers");
const WorkflowHelpers_1 = require("./WorkflowHelpers");
const nodes_api_1 = require("./api/nodes.api");
const workflows_controller_1 = require("./workflows/workflows.controller");
const constants_1 = require("./constants");
const credentials_controller_1 = require("./credentials/credentials.controller");
const oauth2Credential_api_1 = require("./credentials/oauth2Credential.api");
const UserManagement_1 = require("./UserManagement");
const jwt_1 = require("./UserManagement/auth/jwt");
const executions_api_1 = require("./api/executions.api");
const nodeTypes_api_1 = require("./api/nodeTypes.api");
const tags_api_1 = require("./api/tags.api");
const PublicApi_1 = require("./PublicApi");
const telemetryScripts = __importStar(require("./telemetry/scripts"));
const UserManagementHelper_1 = require("./UserManagement/UserManagementHelper");
const _1 = require(".");
const fast_glob_1 = __importDefault(require("fast-glob"));
const ResponseHelper_1 = require("./ResponseHelper");
const CurlConverterHelper_1 = require("./CurlConverterHelper");
require('body-parser-xml')(body_parser_1.default);
const exec = (0, util_1.promisify)(child_process_1.exec);
exports.externalHooks = (0, _1.ExternalHooks)();
class App {
    constructor() {
        this.app = (0, express_1.default)();
        this.app.disable('x-powered-by');
        this.endpointWebhook = config_1.default.getEnv('endpoints.webhook');
        this.endpointWebhookWaiting = config_1.default.getEnv('endpoints.webhookWaiting');
        this.endpointWebhookTest = config_1.default.getEnv('endpoints.webhookTest');
        this.defaultWorkflowName = config_1.default.getEnv('workflows.defaultName');
        this.defaultCredentialsName = config_1.default.getEnv('credentials.defaultName');
        this.saveDataErrorExecution = config_1.default.get('executions.saveDataOnError');
        this.saveDataSuccessExecution = config_1.default.get('executions.saveDataOnSuccess');
        this.saveManualExecutions = config_1.default.get('executions.saveDataManualExecutions');
        this.executionTimeout = config_1.default.get('executions.timeout');
        this.maxExecutionTimeout = config_1.default.get('executions.maxTimeout');
        this.payloadSizeMax = config_1.default.get('endpoints.payloadSizeMax');
        this.timezone = config_1.default.get('generic.timezone');
        this.restEndpoint = config_1.default.get('endpoints.rest');
        this.publicApiEndpoint = config_1.default.get('publicApi.path');
        this.activeWorkflowRunner = _1.ActiveWorkflowRunner.getInstance();
        this.testWebhooks = _1.TestWebhooks.getInstance();
        this.push = _1.Push.getInstance();
        this.activeExecutionsInstance = _1.ActiveExecutions.getInstance();
        this.waitTracker = (0, _1.WaitTracker)();
        this.protocol = config_1.default.getEnv('protocol');
        this.sslKey = config_1.default.getEnv('ssl_key');
        this.sslCert = config_1.default.getEnv('ssl_cert');
        this.externalHooks = exports.externalHooks;
        this.presetCredentialsLoaded = false;
        this.endpointPresetCredentials = config_1.default.getEnv('credentials.overwrite.endpoint');
        const urlBaseWebhook = _1.WebhookHelpers.getWebhookBaseUrl();
        const telemetrySettings = {
            enabled: config_1.default.getEnv('diagnostics.enabled'),
        };
        if (telemetrySettings.enabled) {
            const conf = config_1.default.getEnv('diagnostics.config.frontend');
            const [key, url] = conf.split(';');
            if (!key || !url) {
                n8n_workflow_1.LoggerProxy.warn('Diagnostics frontend config is invalid');
                telemetrySettings.enabled = false;
            }
            telemetrySettings.config = { key, url };
        }
        const instanceBaseUrl = (0, UserManagementHelper_1.getInstanceBaseUrl)();
        this.frontendSettings = {
            endpointWebhook: this.endpointWebhook,
            endpointWebhookTest: this.endpointWebhookTest,
            saveDataErrorExecution: this.saveDataErrorExecution,
            saveDataSuccessExecution: this.saveDataSuccessExecution,
            saveManualExecutions: this.saveManualExecutions,
            executionTimeout: this.executionTimeout,
            maxExecutionTimeout: this.maxExecutionTimeout,
            workflowCallerPolicyDefaultOption: config_1.default.getEnv('workflows.callerPolicyDefaultOption'),
            timezone: this.timezone,
            urlBaseWebhook,
            urlBaseEditor: instanceBaseUrl,
            versionCli: '',
            oauthCallbackUrls: {
                oauth1: `${instanceBaseUrl}/${this.restEndpoint}/oauth1-credential/callback`,
                oauth2: `${instanceBaseUrl}/${this.restEndpoint}/oauth2-credential/callback`,
            },
            versionNotifications: {
                enabled: config_1.default.getEnv('versionNotifications.enabled'),
                endpoint: config_1.default.getEnv('versionNotifications.endpoint'),
                infoUrl: config_1.default.getEnv('versionNotifications.infoUrl'),
            },
            instanceId: '',
            telemetry: telemetrySettings,
            personalizationSurveyEnabled: config_1.default.getEnv('personalization.enabled') && config_1.default.getEnv('diagnostics.enabled'),
            defaultLocale: config_1.default.getEnv('defaultLocale'),
            userManagement: {
                enabled: (0, UserManagementHelper_1.isUserManagementEnabled)(),
                showSetupOnFirstLoad: config_1.default.getEnv('userManagement.disabled') === false &&
                    config_1.default.getEnv('userManagement.isInstanceOwnerSetUp') === false &&
                    config_1.default.getEnv('userManagement.skipInstanceOwnerSetup') === false,
                smtpSetup: (0, UserManagementHelper_1.isEmailSetUp)(),
            },
            publicApi: {
                enabled: config_1.default.getEnv('publicApi.disabled') === false,
                latestVersion: 1,
                path: config_1.default.getEnv('publicApi.path'),
            },
            workflowTagsDisabled: config_1.default.getEnv('workflowTagsDisabled'),
            logLevel: config_1.default.getEnv('logs.level'),
            hiringBannerEnabled: config_1.default.getEnv('hiringBanner.enabled'),
            templates: {
                enabled: config_1.default.getEnv('templates.enabled'),
                host: config_1.default.getEnv('templates.host'),
            },
            onboardingCallPromptEnabled: config_1.default.getEnv('onboardingCallPrompt.enabled'),
            executionMode: config_1.default.getEnv('executions.mode'),
            communityNodesEnabled: config_1.default.getEnv('nodes.communityPackages.enabled'),
            deployment: {
                type: config_1.default.getEnv('deployment.type'),
            },
            isNpmAvailable: false,
            allowedModules: {
                builtIn: process.env.NODE_FUNCTION_ALLOW_BUILTIN,
                external: process.env.NODE_FUNCTION_ALLOW_EXTERNAL,
            },
            enterprise: {
                sharing: false,
                workflowSharing: false,
            },
        };
    }
    getCurrentDate() {
        return new Date();
    }
    getSettingsForFrontend() {
        Object.assign(this.frontendSettings.userManagement, {
            enabled: (0, UserManagementHelper_1.isUserManagementEnabled)(),
            showSetupOnFirstLoad: config_1.default.getEnv('userManagement.disabled') === false &&
                config_1.default.getEnv('userManagement.isInstanceOwnerSetUp') === false &&
                config_1.default.getEnv('userManagement.skipInstanceOwnerSetup') === false,
        });
        Object.assign(this.frontendSettings.enterprise, {
            sharing: (0, UserManagementHelper_1.isSharingEnabled)(),
            workflowSharing: config_1.default.getEnv('enterprise.workflowSharingEnabled'),
        });
        if (config_1.default.get('nodes.packagesMissing').length > 0) {
            this.frontendSettings.missingPackages = true;
        }
        return this.frontendSettings;
    }
    async config() {
        const enableMetrics = config_1.default.getEnv('endpoints.metrics.enable');
        let register;
        if (enableMetrics) {
            const prefix = config_1.default.getEnv('endpoints.metrics.prefix');
            register = new prom_client_1.default.Registry();
            register.setDefaultLabels({ prefix });
            prom_client_1.default.collectDefaultMetrics({ register });
        }
        this.frontendSettings.isNpmAvailable = await exec('npm --version')
            .then(() => true)
            .catch(() => false);
        this.versions = await _1.GenericHelpers.getVersions();
        this.frontendSettings.versionCli = this.versions.cli;
        this.frontendSettings.instanceId = await n8n_core_1.UserSettings.getInstanceId();
        await this.externalHooks.run('frontend.settings', [this.frontendSettings]);
        const excludeEndpoints = config_1.default.getEnv('security.excludeEndpoints');
        const ignoredEndpoints = [
            'assets',
            'healthz',
            'metrics',
            this.endpointWebhook,
            this.endpointWebhookTest,
            this.endpointPresetCredentials,
            config_1.default.getEnv('publicApi.disabled') ? this.publicApiEndpoint : '',
            ...excludeEndpoints.split(':'),
        ].filter((u) => !!u);
        const authIgnoreRegex = new RegExp(`^\/(${ignoredEndpoints.join('|')})\/?.*$`);
        const basicAuthActive = config_1.default.getEnv('security.basicAuth.active');
        if (basicAuthActive) {
            const basicAuthUser = (await _1.GenericHelpers.getConfigValue('security.basicAuth.user'));
            if (basicAuthUser === '') {
                throw new Error('Basic auth is activated but no user got defined. Please set one!');
            }
            const basicAuthPassword = (await _1.GenericHelpers.getConfigValue('security.basicAuth.password'));
            if (basicAuthPassword === '') {
                throw new Error('Basic auth is activated but no password got defined. Please set one!');
            }
            const basicAuthHashEnabled = (await _1.GenericHelpers.getConfigValue('security.basicAuth.hash'));
            let validPassword = null;
            this.app.use(async (req, res, next) => {
                if (authIgnoreRegex.exec(req.url) ||
                    config_1.default.getEnv('userManagement.isInstanceOwnerSetUp')) {
                    return next();
                }
                const realm = 'n8n - Editor UI';
                const basicAuthData = (0, basic_auth_1.default)(req);
                if (basicAuthData === undefined) {
                    return _1.ResponseHelper.basicAuthAuthorizationError(res, realm, 'Authorization is required!');
                }
                if (basicAuthData.name === basicAuthUser) {
                    if (basicAuthHashEnabled) {
                        if (validPassword === null &&
                            (await (0, bcryptjs_1.compare)(basicAuthData.pass, basicAuthPassword))) {
                            validPassword = basicAuthData.pass;
                        }
                        if (validPassword === basicAuthData.pass && validPassword !== null) {
                            return next();
                        }
                    }
                    else if (basicAuthData.pass === basicAuthPassword) {
                        return next();
                    }
                }
                return _1.ResponseHelper.basicAuthAuthorizationError(res, realm, 'Authorization data is wrong!');
            });
        }
        const jwtAuthActive = config_1.default.getEnv('security.jwtAuth.active');
        if (jwtAuthActive) {
            const jwtAuthHeader = (await _1.GenericHelpers.getConfigValue('security.jwtAuth.jwtHeader'));
            if (jwtAuthHeader === '') {
                throw new Error('JWT auth is activated but no request header was defined. Please set one!');
            }
            const jwksUri = (await _1.GenericHelpers.getConfigValue('security.jwtAuth.jwksUri'));
            if (jwksUri === '') {
                throw new Error('JWT auth is activated but no JWK Set URI was defined. Please set one!');
            }
            const jwtHeaderValuePrefix = (await _1.GenericHelpers.getConfigValue('security.jwtAuth.jwtHeaderValuePrefix'));
            const jwtIssuer = (await _1.GenericHelpers.getConfigValue('security.jwtAuth.jwtIssuer'));
            const jwtNamespace = (await _1.GenericHelpers.getConfigValue('security.jwtAuth.jwtNamespace'));
            const jwtAllowedTenantKey = (await _1.GenericHelpers.getConfigValue('security.jwtAuth.jwtAllowedTenantKey'));
            const jwtAllowedTenant = (await _1.GenericHelpers.getConfigValue('security.jwtAuth.jwtAllowedTenant'));
            function isTenantAllowed(decodedToken) {
                if (jwtNamespace === '' || jwtAllowedTenantKey === '' || jwtAllowedTenant === '') {
                    return true;
                }
                for (const [k, v] of Object.entries(decodedToken)) {
                    if (k === jwtNamespace) {
                        for (const [kn, kv] of Object.entries(v)) {
                            if (kn === jwtAllowedTenantKey && kv === jwtAllowedTenant) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            this.app.use((req, res, next) => {
                if (authIgnoreRegex.exec(req.url)) {
                    return next();
                }
                let token = req.header(jwtAuthHeader);
                if (token === undefined || token === '') {
                    return _1.ResponseHelper.jwtAuthAuthorizationError(res, 'Missing token');
                }
                if (jwtHeaderValuePrefix !== '' && token.startsWith(jwtHeaderValuePrefix)) {
                    token = token.replace(`${jwtHeaderValuePrefix} `, '').trimLeft();
                }
                const jwkClient = (0, jwks_rsa_1.default)({ cache: true, jwksUri });
                function getKey(header, callback) {
                    jwkClient.getSigningKey(header.kid, (err, key) => {
                        if (err)
                            throw _1.ResponseHelper.jwtAuthAuthorizationError(res, err.message);
                        const signingKey = key.publicKey || key.rsaPublicKey;
                        callback(null, signingKey);
                    });
                }
                const jwtVerifyOptions = {
                    issuer: jwtIssuer !== '' ? jwtIssuer : undefined,
                    ignoreExpiration: false,
                };
                jsonwebtoken_1.default.verify(token, getKey, jwtVerifyOptions, (err, decoded) => {
                    if (err) {
                        _1.ResponseHelper.jwtAuthAuthorizationError(res, 'Invalid token');
                    }
                    else if (!isTenantAllowed(decoded)) {
                        _1.ResponseHelper.jwtAuthAuthorizationError(res, 'Tenant not allowed');
                    }
                    else {
                        next();
                    }
                });
            });
        }
        if (!config_1.default.getEnv('publicApi.disabled')) {
            const { apiRouters, apiLatestVersion } = await (0, PublicApi_1.loadPublicApiVersions)(this.publicApiEndpoint);
            this.app.use(...apiRouters);
            this.frontendSettings.publicApi.latestVersion = apiLatestVersion;
        }
        this.app.use((0, cookie_parser_1.default)());
        this.app.use(async (req, res, next) => {
            var _a, _b;
            if (req.url.indexOf(`/${this.restEndpoint}/push`) === 0) {
                if (req.query.sessionId === undefined) {
                    next(new Error('The query parameter "sessionId" is missing!'));
                    return;
                }
                if ((0, UserManagementHelper_1.isUserManagementEnabled)()) {
                    try {
                        const authCookie = (_b = (_a = req.cookies) === null || _a === void 0 ? void 0 : _a[constants_1.AUTH_COOKIE_NAME]) !== null && _b !== void 0 ? _b : '';
                        await (0, jwt_1.resolveJwt)(authCookie);
                    }
                    catch (error) {
                        res.status(401).send('Unauthorized');
                        return;
                    }
                }
                this.push.add(req.query.sessionId, req, res);
                return;
            }
            next();
        });
        this.app.use((0, compression_1.default)());
        this.app.use((req, res, next) => {
            req.parsedUrl = (0, parseurl_1.default)(req);
            req.rawBody = Buffer.from('', 'base64');
            next();
        });
        this.app.use(body_parser_1.default.json({
            limit: `${this.payloadSizeMax}mb`,
            verify: (req, res, buf) => {
                req.rawBody = buf;
            },
        }));
        this.app.use(body_parser_1.default.xml({
            limit: `${this.payloadSizeMax}mb`,
            xmlParseOptions: {
                normalize: true,
                normalizeTags: true,
                explicitArray: false,
            },
            verify: (req, res, buf) => {
                req.rawBody = buf;
            },
        }));
        this.app.use(body_parser_1.default.text({
            limit: `${this.payloadSizeMax}mb`,
            verify: (req, res, buf) => {
                req.rawBody = buf;
            },
        }));
        this.app.use((0, connect_history_api_fallback_1.default)({
            rewrites: [
                {
                    from: new RegExp(`^/(${[this.restEndpoint, ...ignoredEndpoints].join('|')})/?.*$`),
                    to: (context) => {
                        return context.parsedUrl.pathname.toString();
                    },
                },
            ],
        }));
        this.app.use(body_parser_1.default.urlencoded({
            limit: `${this.payloadSizeMax}mb`,
            extended: false,
            verify: (req, res, buf) => {
                req.rawBody = buf;
            },
        }));
        if (process.env.NODE_ENV !== 'production') {
            this.app.use((req, res, next) => {
                res.header('Access-Control-Allow-Origin', 'http://localhost:8080');
                res.header('Access-Control-Allow-Credentials', 'true');
                res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');
                res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, sessionid');
                next();
            });
        }
        this.app.use((req, res, next) => {
            if (!_1.Db.isInitialized) {
                const error = new _1.ResponseHelper.ResponseError('Database is not ready!', undefined, 503);
                return _1.ResponseHelper.sendErrorResponse(res, error);
            }
            next();
        });
        await UserManagement_1.userManagementRouter.addRoutes.apply(this, [ignoredEndpoints, this.restEndpoint]);
        this.app.use(`/${this.restEndpoint}/credentials`, credentials_controller_1.credentialsController);
        if (config_1.default.getEnv('nodes.communityPackages.enabled')) {
            this.app.use(`/${this.restEndpoint}/nodes`, nodes_api_1.nodesController);
        }
        this.app.get('/healthz', async (req, res) => {
            n8n_workflow_1.LoggerProxy.debug('Health check started!');
            const connection = (0, typeorm_1.getConnectionManager)().get();
            try {
                if (!connection.isConnected) {
                    throw new Error('No active database connection!');
                }
                await connection.query('SELECT 1');
            }
            catch (err) {
                n8n_workflow_1.LoggerProxy.error('No Database connection!', err);
                const error = new _1.ResponseHelper.ResponseError('No Database connection!', undefined, 503);
                return _1.ResponseHelper.sendErrorResponse(res, error);
            }
            const responseData = {
                status: 'ok',
            };
            n8n_workflow_1.LoggerProxy.debug('Health check completed successfully!');
            _1.ResponseHelper.sendSuccessResponse(res, responseData, true, 200);
        });
        if (enableMetrics) {
            this.app.get('/metrics', async (req, res) => {
                const response = await register.metrics();
                res.setHeader('Content-Type', register.contentType);
                _1.ResponseHelper.sendSuccessResponse(res, response, true, 200);
            });
        }
        this.app.use(`/${this.restEndpoint}/workflows`, workflows_controller_1.workflowsController);
        this.app.use(`/${this.restEndpoint}/tags`, tags_api_1.tagsController);
        this.app.get(`/${this.restEndpoint}/node-parameter-options`, _1.ResponseHelper.send(async (req) => {
            const nodeTypeAndVersion = (0, n8n_workflow_1.jsonParse)(req.query.nodeTypeAndVersion);
            const { path, methodName } = req.query;
            const currentNodeParameters = (0, n8n_workflow_1.jsonParse)(req.query.currentNodeParameters);
            let credentials;
            if (req.query.credentials) {
                credentials = (0, n8n_workflow_1.jsonParse)(req.query.credentials);
            }
            const loadDataInstance = new n8n_core_1.LoadNodeParameterOptions(nodeTypeAndVersion, (0, _1.NodeTypes)(), path, currentNodeParameters, credentials);
            const additionalData = await _1.WorkflowExecuteAdditionalData.getBase(req.user.id, currentNodeParameters);
            if (methodName) {
                return loadDataInstance.getOptionsViaMethodName(methodName, additionalData);
            }
            if (req.query.loadOptions) {
                return loadDataInstance.getOptionsViaRequestProperty((0, n8n_workflow_1.jsonParse)(req.query.loadOptions), additionalData);
            }
            return [];
        }));
        this.app.get(`/${this.restEndpoint}/nodes-list-search`, _1.ResponseHelper.send(async (req, res) => {
            const nodeTypeAndVersion = (0, n8n_workflow_1.jsonParse)(req.query.nodeTypeAndVersion);
            const { path, methodName } = req.query;
            if (!req.query.currentNodeParameters) {
                throw new ResponseHelper_1.ResponseError('Parameter currentNodeParameters is required.', undefined, 400);
            }
            const currentNodeParameters = (0, n8n_workflow_1.jsonParse)(req.query.currentNodeParameters);
            let credentials;
            if (req.query.credentials) {
                credentials = (0, n8n_workflow_1.jsonParse)(req.query.credentials);
            }
            const listSearchInstance = new n8n_core_1.LoadNodeListSearch(nodeTypeAndVersion, (0, _1.NodeTypes)(), path, currentNodeParameters, credentials);
            const additionalData = await _1.WorkflowExecuteAdditionalData.getBase(req.user.id, currentNodeParameters);
            if (methodName) {
                return listSearchInstance.getOptionsViaMethodName(methodName, additionalData, req.query.filter, req.query.paginationToken);
            }
            throw new ResponseHelper_1.ResponseError('Parameter methodName is required.', undefined, 400);
        }));
        this.app.get(`/${this.restEndpoint}/node-types`, _1.ResponseHelper.send(async (req, res) => {
            const returnData = [];
            const onlyLatest = req.query.onlyLatest === 'true';
            const nodeTypes = (0, _1.NodeTypes)();
            const allNodes = nodeTypes.getAll();
            const getNodeDescription = (nodeType) => {
                const nodeInfo = { ...nodeType.description };
                if (req.query.includeProperties !== 'true') {
                    delete nodeInfo.properties;
                }
                return nodeInfo;
            };
            if (onlyLatest) {
                allNodes.forEach((nodeData) => {
                    const nodeType = n8n_workflow_1.NodeHelpers.getVersionedNodeType(nodeData);
                    const nodeInfo = getNodeDescription(nodeType);
                    returnData.push(nodeInfo);
                });
            }
            else {
                allNodes.forEach((nodeData) => {
                    const allNodeTypes = n8n_workflow_1.NodeHelpers.getVersionedNodeTypeAll(nodeData);
                    allNodeTypes.forEach((element) => {
                        const nodeInfo = getNodeDescription(element);
                        returnData.push(nodeInfo);
                    });
                });
            }
            return returnData;
        }));
        this.app.get(`/${this.restEndpoint}/credential-translation`, _1.ResponseHelper.send(async (req, res) => {
            const translationPath = (0, TranslationHelpers_1.getCredentialTranslationPath)({
                locale: this.frontendSettings.defaultLocale,
                credentialType: req.query.credentialType,
            });
            try {
                return require(translationPath);
            }
            catch (error) {
                return null;
            }
        }));
        this.app.get(`/${this.restEndpoint}/node-translation-headers`, _1.ResponseHelper.send(async (req, res) => {
            const packagesPath = (0, path_1.join)(__dirname, '..', '..', '..');
            const headersPath = (0, path_1.join)(packagesPath, 'nodes-base', 'dist', 'nodes', 'headers');
            try {
                await (0, promises_1.access)(`${headersPath}.js`);
            }
            catch (_) {
                return;
            }
            try {
                return require(headersPath);
            }
            catch (error) {
                res.status(500).send('Failed to load headers file');
            }
        }));
        this.app.use(`/${this.restEndpoint}/node-types`, nodeTypes_api_1.nodeTypesController);
        this.app.get([
            `/${this.restEndpoint}/node-icon/:nodeType`,
            `/${this.restEndpoint}/node-icon/:scope/:nodeType`,
        ], async (req, res) => {
            try {
                const nodeTypeName = `${req.params.scope ? `${req.params.scope}/` : ''}${req.params.nodeType}`;
                const nodeTypes = (0, _1.NodeTypes)();
                const nodeType = nodeTypes.getByNameAndVersion(nodeTypeName);
                if (nodeType === undefined) {
                    res.status(404).send('The nodeType is not known.');
                    return;
                }
                if (nodeType.description.icon === undefined) {
                    res.status(404).send('No icon found for node.');
                    return;
                }
                if (!nodeType.description.icon.startsWith('file:')) {
                    res.status(404).send('Node does not have a file icon.');
                    return;
                }
                const filepath = nodeType.description.icon.substr(5);
                const maxAge = 7 * 24 * 60 * 60 * 1000;
                res.setHeader('Cache-control', `private max-age=${maxAge}`);
                res.sendFile(filepath);
            }
            catch (error) {
                return _1.ResponseHelper.sendErrorResponse(res, error);
            }
        });
        this.app.get(`/${this.restEndpoint}/active`, _1.ResponseHelper.send(async (req) => {
            const activeWorkflows = await this.activeWorkflowRunner.getActiveWorkflows(req.user);
            return activeWorkflows.map(({ id }) => id.toString());
        }));
        this.app.get(`/${this.restEndpoint}/active/error/:id`, _1.ResponseHelper.send(async (req) => {
            const { id: workflowId } = req.params;
            const shared = await _1.Db.collections.SharedWorkflow.findOne({
                relations: ['workflow'],
                where: (0, WorkflowHelpers_1.whereClause)({
                    user: req.user,
                    entityType: 'workflow',
                    entityId: workflowId,
                }),
            });
            if (!shared) {
                n8n_workflow_1.LoggerProxy.info('User attempted to access workflow errors without permissions', {
                    workflowId,
                    userId: req.user.id,
                });
                throw new _1.ResponseHelper.ResponseError(`Workflow with ID "${workflowId}" could not be found.`, undefined, 400);
            }
            return this.activeWorkflowRunner.getActivationError(workflowId);
        }));
        this.app.post(`/${this.restEndpoint}/curl-to-json`, _1.ResponseHelper.send(async (req, res) => {
            var _a;
            const curlCommand = (_a = req.body.curlCommand) !== null && _a !== void 0 ? _a : '';
            try {
                const parameters = (0, CurlConverterHelper_1.toHttpNodeParameters)(curlCommand);
                return _1.ResponseHelper.flattenObject(parameters, 'parameters');
            }
            catch (e) {
                throw new _1.ResponseHelper.ResponseError(`Invalid cURL command`, undefined, 400);
            }
        }));
        this.app.get(`/${this.restEndpoint}/credential-types`, _1.ResponseHelper.send(async (req, res) => {
            const returnData = [];
            const credentialTypes = (0, _1.CredentialTypes)();
            credentialTypes.getAll().forEach((credentialData) => {
                returnData.push(credentialData);
            });
            return returnData;
        }));
        this.app.get(`/${this.restEndpoint}/credential-icon/:credentialType`, async (req, res) => {
            try {
                const credentialName = req.params.credentialType;
                const credentialType = (0, _1.CredentialTypes)().getByName(credentialName);
                if (credentialType === undefined) {
                    res.status(404).send('The credentialType is not known.');
                    return;
                }
                if (credentialType.icon === undefined) {
                    res.status(404).send('No icon found for credential.');
                    return;
                }
                if (!credentialType.icon.startsWith('file:')) {
                    res.status(404).send('Credential does not have a file icon.');
                    return;
                }
                const filepath = credentialType.icon.substr(5);
                const maxAge = 7 * 24 * 60 * 60 * 1000;
                res.setHeader('Cache-control', `private max-age=${maxAge}`);
                res.sendFile(filepath);
            }
            catch (error) {
                return _1.ResponseHelper.sendErrorResponse(res, error);
            }
        });
        this.app.get(`/${this.restEndpoint}/oauth1-credential/auth`, _1.ResponseHelper.send(async (req) => {
            const { id: credentialId } = req.query;
            if (!credentialId) {
                n8n_workflow_1.LoggerProxy.error('OAuth1 credential authorization failed due to missing credential ID');
                throw new _1.ResponseHelper.ResponseError('Required credential ID is missing', undefined, 400);
            }
            const credential = await (0, _1.getCredentialForUser)(credentialId, req.user);
            if (!credential) {
                n8n_workflow_1.LoggerProxy.error('OAuth1 credential authorization failed because the current user does not have the correct permissions', { userId: req.user.id });
                throw new _1.ResponseHelper.ResponseError(constants_1.RESPONSE_ERROR_MESSAGES.NO_CREDENTIAL, undefined, 404);
            }
            let encryptionKey;
            try {
                encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
            }
            catch (error) {
                throw new _1.ResponseHelper.ResponseError(error.message, undefined, 500);
            }
            const mode = 'internal';
            const timezone = config_1.default.getEnv('generic.timezone');
            const credentialsHelper = new _1.CredentialsHelper(encryptionKey);
            const decryptedDataOriginal = await credentialsHelper.getDecrypted(credential, credential.type, mode, timezone, true);
            const oauthCredentials = credentialsHelper.applyDefaultsAndOverwrites(decryptedDataOriginal, credential.type, mode, timezone);
            const signatureMethod = oauthCredentials.signatureMethod;
            const oAuthOptions = {
                consumer: {
                    key: oauthCredentials.consumerKey,
                    secret: oauthCredentials.consumerSecret,
                },
                signature_method: signatureMethod,
                hash_function(base, key) {
                    const algorithm = signatureMethod === 'HMAC-SHA1' ? 'sha1' : 'sha256';
                    return (0, crypto_1.createHmac)(algorithm, key).update(base).digest('base64');
                },
            };
            const oauthRequestData = {
                oauth_callback: `${_1.WebhookHelpers.getWebhookBaseUrl()}${this.restEndpoint}/oauth1-credential/callback?cid=${credentialId}`,
            };
            await this.externalHooks.run('oauth1.authenticate', [oAuthOptions, oauthRequestData]);
            const oauth = new oauth_1_0a_1.default(oAuthOptions);
            const options = {
                method: 'POST',
                url: oauthCredentials.requestTokenUrl,
                data: oauthRequestData,
            };
            const data = oauth.toHeader(oauth.authorize(options));
            options.headers = data;
            const { data: response } = await axios_1.default.request(options);
            const paramsParser = new URLSearchParams(response);
            const responseJson = Object.fromEntries(paramsParser.entries());
            const returnUri = `${oauthCredentials.authUrl}?oauth_token=${responseJson.oauth_token}`;
            const credentials = new n8n_core_1.Credentials(credential, credential.type, credential.nodesAccess);
            credentials.setData(decryptedDataOriginal, encryptionKey);
            const newCredentialsData = credentials.getDataToSave();
            newCredentialsData.updatedAt = this.getCurrentDate();
            await _1.Db.collections.Credentials.update(credentialId, newCredentialsData);
            n8n_workflow_1.LoggerProxy.verbose('OAuth1 authorization successful for new credential', {
                userId: req.user.id,
                credentialId,
            });
            return returnUri;
        }));
        this.app.get(`/${this.restEndpoint}/oauth1-credential/callback`, async (req, res) => {
            var _a, _b, _c, _d, _e;
            try {
                const { oauth_verifier, oauth_token, cid: credentialId } = req.query;
                if (!oauth_verifier || !oauth_token) {
                    const errorResponse = new _1.ResponseHelper.ResponseError(`Insufficient parameters for OAuth1 callback. Received following query parameters: ${JSON.stringify(req.query)}`, undefined, 503);
                    n8n_workflow_1.LoggerProxy.error('OAuth1 callback failed because of insufficient parameters received', {
                        userId: (_a = req.user) === null || _a === void 0 ? void 0 : _a.id,
                        credentialId,
                    });
                    return _1.ResponseHelper.sendErrorResponse(res, errorResponse);
                }
                const credential = await (0, _1.getCredentialWithoutUser)(credentialId);
                if (!credential) {
                    n8n_workflow_1.LoggerProxy.error('OAuth1 callback failed because of insufficient user permissions', {
                        userId: (_b = req.user) === null || _b === void 0 ? void 0 : _b.id,
                        credentialId,
                    });
                    const errorResponse = new _1.ResponseHelper.ResponseError(constants_1.RESPONSE_ERROR_MESSAGES.NO_CREDENTIAL, undefined, 404);
                    return _1.ResponseHelper.sendErrorResponse(res, errorResponse);
                }
                let encryptionKey;
                try {
                    encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
                }
                catch (error) {
                    throw new _1.ResponseHelper.ResponseError(error.message, undefined, 500);
                }
                const mode = 'internal';
                const timezone = config_1.default.getEnv('generic.timezone');
                const credentialsHelper = new _1.CredentialsHelper(encryptionKey);
                const decryptedDataOriginal = await credentialsHelper.getDecrypted(credential, credential.type, mode, timezone, true);
                const oauthCredentials = credentialsHelper.applyDefaultsAndOverwrites(decryptedDataOriginal, credential.type, mode, timezone);
                const options = {
                    method: 'POST',
                    url: oauthCredentials.accessTokenUrl,
                    params: {
                        oauth_token,
                        oauth_verifier,
                    },
                };
                let oauthToken;
                try {
                    oauthToken = await axios_1.default.request(options);
                }
                catch (error) {
                    n8n_workflow_1.LoggerProxy.error('Unable to fetch tokens for OAuth1 callback', {
                        userId: (_c = req.user) === null || _c === void 0 ? void 0 : _c.id,
                        credentialId,
                    });
                    const errorResponse = new _1.ResponseHelper.ResponseError('Unable to get access tokens!', undefined, 404);
                    return _1.ResponseHelper.sendErrorResponse(res, errorResponse);
                }
                const paramParser = new URLSearchParams(oauthToken.data);
                const oauthTokenJson = Object.fromEntries(paramParser.entries());
                decryptedDataOriginal.oauthTokenData = oauthTokenJson;
                const credentials = new n8n_core_1.Credentials(credential, credential.type, credential.nodesAccess);
                credentials.setData(decryptedDataOriginal, encryptionKey);
                const newCredentialsData = credentials.getDataToSave();
                newCredentialsData.updatedAt = this.getCurrentDate();
                await _1.Db.collections.Credentials.update(credentialId, newCredentialsData);
                n8n_workflow_1.LoggerProxy.verbose('OAuth1 callback successful for new credential', {
                    userId: (_d = req.user) === null || _d === void 0 ? void 0 : _d.id,
                    credentialId,
                });
                res.sendFile((0, path_1.resolve)(__dirname, '../../templates/oauth-callback.html'));
            }
            catch (error) {
                n8n_workflow_1.LoggerProxy.error('OAuth1 callback failed because of insufficient user permissions', {
                    userId: (_e = req.user) === null || _e === void 0 ? void 0 : _e.id,
                    credentialId: req.query.cid,
                });
                return _1.ResponseHelper.sendErrorResponse(res, error);
            }
        });
        this.app.use(`/${this.restEndpoint}/oauth2-credential`, oauth2Credential_api_1.oauth2CredentialController);
        this.app.use(`/${this.restEndpoint}/executions`, executions_api_1.executionsController);
        this.app.get(`/${this.restEndpoint}/executions-current`, _1.ResponseHelper.send(async (req) => {
            if (config_1.default.getEnv('executions.mode') === 'queue') {
                const currentJobs = await Queue.getInstance().getJobs(['active', 'waiting']);
                const currentlyRunningQueueIds = currentJobs.map((job) => job.data.executionId);
                const currentlyRunningManualExecutions = this.activeExecutionsInstance.getActiveExecutions();
                const manualExecutionIds = currentlyRunningManualExecutions.map((execution) => execution.id);
                const currentlyRunningExecutionIds = currentlyRunningQueueIds.concat(manualExecutionIds);
                if (!currentlyRunningExecutionIds.length)
                    return [];
                const findOptions = {
                    select: ['id', 'workflowId', 'mode', 'retryOf', 'startedAt'],
                    order: { id: 'DESC' },
                    where: {
                        id: (0, typeorm_1.In)(currentlyRunningExecutionIds),
                    },
                };
                const sharedWorkflowIds = await (0, WorkflowHelpers_1.getSharedWorkflowIds)(req.user);
                if (!sharedWorkflowIds.length)
                    return [];
                if (req.query.filter) {
                    const { workflowId } = (0, n8n_workflow_1.jsonParse)(req.query.filter);
                    if (workflowId && sharedWorkflowIds.includes(workflowId)) {
                        Object.assign(findOptions.where, { workflowId });
                    }
                }
                else {
                    Object.assign(findOptions.where, { workflowId: (0, typeorm_1.In)(sharedWorkflowIds) });
                }
                const executions = await _1.Db.collections.Execution.find(findOptions);
                if (!executions.length)
                    return [];
                return executions.map((execution) => {
                    return {
                        id: execution.id,
                        workflowId: execution.workflowId,
                        mode: execution.mode,
                        retryOf: execution.retryOf !== null ? execution.retryOf : undefined,
                        startedAt: new Date(execution.startedAt),
                    };
                });
            }
            const executingWorkflows = this.activeExecutionsInstance.getActiveExecutions();
            const returnData = [];
            const filter = req.query.filter ? (0, n8n_workflow_1.jsonParse)(req.query.filter) : {};
            const sharedWorkflowIds = await (0, WorkflowHelpers_1.getSharedWorkflowIds)(req.user).then((ids) => ids.map((id) => id.toString()));
            for (const data of executingWorkflows) {
                if ((filter.workflowId !== undefined && filter.workflowId !== data.workflowId) ||
                    (data.workflowId !== undefined &&
                        !sharedWorkflowIds.includes(data.workflowId.toString()))) {
                    continue;
                }
                returnData.push({
                    id: data.id.toString(),
                    workflowId: data.workflowId === undefined ? '' : data.workflowId.toString(),
                    mode: data.mode,
                    retryOf: data.retryOf,
                    startedAt: new Date(data.startedAt),
                });
            }
            returnData.sort((a, b) => parseInt(b.id, 10) - parseInt(a.id, 10));
            return returnData;
        }));
        this.app.post(`/${this.restEndpoint}/executions-current/:id/stop`, _1.ResponseHelper.send(async (req) => {
            const { id: executionId } = req.params;
            const sharedWorkflowIds = await (0, WorkflowHelpers_1.getSharedWorkflowIds)(req.user);
            if (!sharedWorkflowIds.length) {
                throw new _1.ResponseHelper.ResponseError('Execution not found', undefined, 404);
            }
            const execution = await _1.Db.collections.Execution.findOne({
                where: {
                    id: executionId,
                    workflowId: (0, typeorm_1.In)(sharedWorkflowIds),
                },
            });
            if (!execution) {
                throw new _1.ResponseHelper.ResponseError('Execution not found', undefined, 404);
            }
            if (config_1.default.getEnv('executions.mode') === 'queue') {
                const result = await this.activeExecutionsInstance.stopExecution(req.params.id);
                if (result === undefined) {
                    try {
                        return await this.waitTracker.stopExecution(req.params.id);
                    }
                    catch (error) {
                    }
                }
                else {
                    return {
                        mode: result.mode,
                        startedAt: new Date(result.startedAt),
                        stoppedAt: result.stoppedAt ? new Date(result.stoppedAt) : undefined,
                        finished: result.finished,
                    };
                }
                const currentJobs = await Queue.getInstance().getJobs(['active', 'waiting']);
                const job = currentJobs.find((job) => job.data.executionId.toString() === req.params.id);
                if (!job) {
                    throw new Error(`Could not stop "${req.params.id}" as it is no longer in queue.`);
                }
                else {
                    await Queue.getInstance().stopJob(job);
                }
                const executionDb = (await _1.Db.collections.Execution.findOne(req.params.id));
                const fullExecutionData = _1.ResponseHelper.unflattenExecutionData(executionDb);
                const returnData = {
                    mode: fullExecutionData.mode,
                    startedAt: new Date(fullExecutionData.startedAt),
                    stoppedAt: fullExecutionData.stoppedAt
                        ? new Date(fullExecutionData.stoppedAt)
                        : undefined,
                    finished: fullExecutionData.finished,
                };
                return returnData;
            }
            const result = await this.activeExecutionsInstance.stopExecution(executionId);
            let returnData;
            if (result === undefined) {
                returnData = await this.waitTracker.stopExecution(executionId);
            }
            else {
                returnData = {
                    mode: result.mode,
                    startedAt: new Date(result.startedAt),
                    stoppedAt: result.stoppedAt ? new Date(result.stoppedAt) : undefined,
                    finished: result.finished,
                };
            }
            return returnData;
        }));
        this.app.delete(`/${this.restEndpoint}/test-webhook/:id`, _1.ResponseHelper.send(async (req, res) => {
            const workflowId = req.params.id;
            return this.testWebhooks.cancelTestWebhook(workflowId);
        }));
        this.app.get(`/${this.restEndpoint}/options/timezones`, _1.ResponseHelper.send(async (req, res) => {
            return google_timezones_json_1.default;
        }));
        this.app.get(`/${this.restEndpoint}/data/:path`, _1.ResponseHelper.send(async (req, res) => {
            const dataPath = req.params.path;
            return n8n_core_1.BinaryDataManager.getInstance()
                .retrieveBinaryDataByIdentifier(dataPath)
                .then((buffer) => {
                return buffer.toString('base64');
            });
        }));
        this.app.get(`/${this.restEndpoint}/settings`, _1.ResponseHelper.send(async (req, res) => {
            void InternalHooksManager_1.InternalHooksManager.getInstance().onFrontendSettingsAPI(req.headers.sessionid);
            return this.getSettingsForFrontend();
        }));
        if (!config_1.default.getEnv('endpoints.disableProductionWebhooksOnMainProcess')) {
            _1.WebhookServer.registerProductionWebhooks.apply(this);
        }
        this.app.all(`/${this.endpointWebhookTest}/*`, async (req, res) => {
            const requestUrl = req.parsedUrl.pathname.slice(this.endpointWebhookTest.length + 2);
            const method = req.method.toUpperCase();
            if (method === 'OPTIONS') {
                let allowedMethods;
                try {
                    allowedMethods = await this.testWebhooks.getWebhookMethods(requestUrl);
                    allowedMethods.push('OPTIONS');
                    res.append('Allow', allowedMethods);
                }
                catch (error) {
                    _1.ResponseHelper.sendErrorResponse(res, error);
                    return;
                }
                res.header('Access-Control-Allow-Origin', '*');
                _1.ResponseHelper.sendSuccessResponse(res, {}, true, 204);
                return;
            }
            if (!WebhookHelpers_1.WEBHOOK_METHODS.includes(method)) {
                _1.ResponseHelper.sendErrorResponse(res, new Error(`The method ${method} is not supported.`));
                return;
            }
            let response;
            try {
                response = await this.testWebhooks.callTestWebhook(method, requestUrl, req, res);
            }
            catch (error) {
                _1.ResponseHelper.sendErrorResponse(res, error);
                return;
            }
            if (response.noWebhookResponse === true) {
                return;
            }
            _1.ResponseHelper.sendSuccessResponse(res, response.data, true, response.responseCode, response.headers);
        });
        if (this.endpointPresetCredentials !== '') {
            this.app.post(`/${this.endpointPresetCredentials}`, async (req, res) => {
                if (!this.presetCredentialsLoaded) {
                    const body = req.body;
                    if (req.headers['content-type'] !== 'application/json') {
                        _1.ResponseHelper.sendErrorResponse(res, new Error('Body must be a valid JSON, make sure the content-type is application/json'));
                        return;
                    }
                    const credentialsOverwrites = (0, _1.CredentialsOverwrites)();
                    await credentialsOverwrites.init(body);
                    this.presetCredentialsLoaded = true;
                    _1.ResponseHelper.sendSuccessResponse(res, { success: true }, true, 200);
                }
                else {
                    _1.ResponseHelper.sendErrorResponse(res, new Error('Preset credentials can be set once'));
                }
            });
        }
        if (!config_1.default.getEnv('endpoints.disableUi')) {
            const n8nPath = config_1.default.getEnv('path');
            const basePathRegEx = /\/{{BASE_PATH}}\//g;
            const hooksUrls = config_1.default.getEnv('externalFrontendHooksUrls');
            let scriptsString = '';
            if (hooksUrls) {
                scriptsString = hooksUrls.split(';').reduce((acc, curr) => {
                    return `${acc}<script src="${curr}"></script>`;
                }, '');
            }
            if (this.frontendSettings.telemetry.enabled) {
                const phLoadingScript = telemetryScripts.createPostHogLoadingScript({
                    apiKey: config_1.default.getEnv('diagnostics.config.posthog.apiKey'),
                    apiHost: config_1.default.getEnv('diagnostics.config.posthog.apiHost'),
                    autocapture: false,
                    disableSessionRecording: config_1.default.getEnv('diagnostics.config.posthog.disableSessionRecording'),
                    debug: config_1.default.getEnv('logs.level') === 'debug',
                });
                scriptsString += phLoadingScript;
            }
            const editorUiDistDir = (0, path_1.join)((0, path_1.dirname)(require.resolve('n8n-editor-ui')), 'dist');
            const generatedStaticDir = (0, path_1.join)(n8n_core_1.UserSettings.getUserHome(), '.cache/n8n/public');
            const closingTitleTag = '</title>';
            const compileFile = async (fileName) => {
                const filePath = (0, path_1.join)(editorUiDistDir, fileName);
                if (/(index\.html)|.*\.(js|css)/.test(filePath) && (0, fs_1.existsSync)(filePath)) {
                    const srcFile = await (0, promises_1.readFile)(filePath, 'utf8');
                    let payload = srcFile
                        .replace(basePathRegEx, n8nPath)
                        .replace(/\/static\//g, n8nPath + 'static/');
                    if (filePath.endsWith('index.html')) {
                        payload = payload.replace(closingTitleTag, closingTitleTag + scriptsString);
                    }
                    const destFile = (0, path_1.join)(generatedStaticDir, fileName);
                    await (0, promises_1.mkdir)((0, path_1.dirname)(destFile), { recursive: true });
                    await (0, promises_1.writeFile)(destFile, payload, 'utf-8');
                }
            };
            await compileFile('index.html');
            const files = await (0, fast_glob_1.default)('**/*.{css,js}', { cwd: editorUiDistDir });
            await Promise.all(files.map(compileFile));
            this.app.use('/', express_1.default.static(generatedStaticDir), express_1.default.static(editorUiDistDir));
            const startTime = new Date().toUTCString();
            this.app.use('/index.html', (req, res, next) => {
                res.setHeader('Last-Modified', startTime);
                next();
            });
        }
    }
}
async function start() {
    const PORT = config_1.default.getEnv('port');
    const ADDRESS = config_1.default.getEnv('listen_address');
    const app = new App();
    await app.config();
    let server;
    if (app.protocol === 'https' && app.sslKey && app.sslCert) {
        const https = require('https');
        const privateKey = (0, fs_1.readFileSync)(app.sslKey, 'utf8');
        const cert = (0, fs_1.readFileSync)(app.sslCert, 'utf8');
        const credentials = { key: privateKey, cert };
        server = https.createServer(credentials, app.app);
    }
    else {
        const http = require('http');
        server = http.createServer(app.app);
    }
    server.listen(PORT, ADDRESS, async () => {
        const versions = await _1.GenericHelpers.getVersions();
        console.log(`n8n ready on ${ADDRESS}, port ${PORT}`);
        console.log(`Version: ${versions.cli}`);
        const defaultLocale = config_1.default.getEnv('defaultLocale');
        if (defaultLocale !== 'en') {
            console.log(`Locale: ${defaultLocale}`);
        }
        await app.externalHooks.run('n8n.ready', [app, config_1.default]);
        const cpus = os_1.default.cpus();
        const binaryDataConfig = config_1.default.getEnv('binaryDataManager');
        const diagnosticInfo = {
            basicAuthActive: config_1.default.getEnv('security.basicAuth.active'),
            databaseType: (await _1.GenericHelpers.getConfigValue('database.type')),
            disableProductionWebhooksOnMainProcess: config_1.default.getEnv('endpoints.disableProductionWebhooksOnMainProcess'),
            notificationsEnabled: config_1.default.getEnv('versionNotifications.enabled'),
            versionCli: versions.cli,
            systemInfo: {
                os: {
                    type: os_1.default.type(),
                    version: os_1.default.version(),
                },
                memory: os_1.default.totalmem() / 1024,
                cpus: {
                    count: cpus.length,
                    model: cpus[0].model,
                    speed: cpus[0].speed,
                },
            },
            executionVariables: {
                executions_process: config_1.default.getEnv('executions.process'),
                executions_mode: config_1.default.getEnv('executions.mode'),
                executions_timeout: config_1.default.getEnv('executions.timeout'),
                executions_timeout_max: config_1.default.getEnv('executions.maxTimeout'),
                executions_data_save_on_error: config_1.default.getEnv('executions.saveDataOnError'),
                executions_data_save_on_success: config_1.default.getEnv('executions.saveDataOnSuccess'),
                executions_data_save_on_progress: config_1.default.getEnv('executions.saveExecutionProgress'),
                executions_data_save_manual_executions: config_1.default.getEnv('executions.saveDataManualExecutions'),
                executions_data_prune: config_1.default.getEnv('executions.pruneData'),
                executions_data_max_age: config_1.default.getEnv('executions.pruneDataMaxAge'),
                executions_data_prune_timeout: config_1.default.getEnv('executions.pruneDataTimeout'),
            },
            deploymentType: config_1.default.getEnv('deployment.type'),
            binaryDataMode: binaryDataConfig.mode,
            n8n_multi_user_allowed: (0, UserManagementHelper_1.isUserManagementEnabled)(),
            smtp_set_up: config_1.default.getEnv('userManagement.emails.mode') === 'smtp',
        };
        void _1.Db.collections
            .Workflow.findOne({
            select: ['createdAt'],
            order: { createdAt: 'ASC' },
        })
            .then(async (workflow) => InternalHooksManager_1.InternalHooksManager.getInstance().onServerStarted(diagnosticInfo, workflow === null || workflow === void 0 ? void 0 : workflow.createdAt));
    });
    server.on('error', (error) => {
        if (error.code === 'EADDRINUSE') {
            console.log(`n8n's port ${PORT} is already in use. Do you have another instance of n8n running already?`);
            process.exit(1);
        }
    });
}
exports.start = start;
//# sourceMappingURL=Server.js.map