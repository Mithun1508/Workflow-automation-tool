"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setTagsForImport = exports.removeRelations = exports.createRelations = exports.getTagsWithCountDb = exports.sortByRequestOrder = void 0;
const typeorm_1 = require("typeorm");
const TagEntity_1 = require("./databases/entities/TagEntity");
function sortByRequestOrder(tags, { requestOrder }) {
    const tagMap = tags.reduce((acc, tag) => {
        acc[tag.id.toString()] = tag;
        return acc;
    }, {});
    return requestOrder.map((tagId) => tagMap[tagId]);
}
exports.sortByRequestOrder = sortByRequestOrder;
async function getTagsWithCountDb(tablePrefix) {
    return (0, typeorm_1.getConnection)()
        .createQueryBuilder()
        .select(`${tablePrefix}tag_entity.id`, 'id')
        .addSelect(`${tablePrefix}tag_entity.name`, 'name')
        .addSelect(`${tablePrefix}tag_entity.createdAt`, 'createdAt')
        .addSelect(`${tablePrefix}tag_entity.updatedAt`, 'updatedAt')
        .addSelect(`COUNT(${tablePrefix}workflows_tags.workflowId)`, 'usageCount')
        .from(`${tablePrefix}tag_entity`, 'tag_entity')
        .leftJoin(`${tablePrefix}workflows_tags`, 'workflows_tags', `${tablePrefix}workflows_tags.tagId = tag_entity.id`)
        .groupBy(`${tablePrefix}tag_entity.id`)
        .getRawMany()
        .then((tagsWithCount) => {
        tagsWithCount.forEach((tag) => {
            tag.id = tag.id.toString();
            tag.usageCount = Number(tag.usageCount);
        });
        return tagsWithCount;
    });
}
exports.getTagsWithCountDb = getTagsWithCountDb;
async function createRelations(workflowId, tagIds, tablePrefix) {
    return (0, typeorm_1.getConnection)()
        .createQueryBuilder()
        .insert()
        .into(`${tablePrefix}workflows_tags`)
        .values(tagIds.map((tagId) => ({ workflowId, tagId })))
        .execute();
}
exports.createRelations = createRelations;
async function removeRelations(workflowId, tablePrefix) {
    return (0, typeorm_1.getConnection)()
        .createQueryBuilder()
        .delete()
        .from(`${tablePrefix}workflows_tags`)
        .where('workflowId = :id', { id: workflowId })
        .execute();
}
exports.removeRelations = removeRelations;
const createTag = async (transactionManager, name) => {
    const tag = new TagEntity_1.TagEntity();
    tag.name = name;
    return transactionManager.save(tag);
};
const findOrCreateTag = async (transactionManager, importTag, tagsEntities) => {
    const identicalMatch = tagsEntities.find((existingTag) => existingTag.id.toString() === importTag.id.toString() &&
        existingTag.createdAt &&
        importTag.createdAt &&
        existingTag.createdAt.getTime() === new Date(importTag.createdAt).getTime());
    if (identicalMatch) {
        return identicalMatch;
    }
    const nameMatch = tagsEntities.find((existingTag) => existingTag.name === importTag.name);
    if (nameMatch) {
        return nameMatch;
    }
    const created = await createTag(transactionManager, importTag.name);
    tagsEntities.push(created);
    return created;
};
const hasTags = (workflow) => 'tags' in workflow && Array.isArray(workflow.tags) && workflow.tags.length > 0;
async function setTagsForImport(transactionManager, workflow, tags) {
    var _a;
    if (!hasTags(workflow)) {
        return;
    }
    const workflowTags = workflow.tags;
    const tagLookupPromises = [];
    for (let i = 0; i < workflowTags.length; i++) {
        if ((_a = workflowTags[i]) === null || _a === void 0 ? void 0 : _a.name) {
            const lookupPromise = findOrCreateTag(transactionManager, workflowTags[i], tags).then((tag) => {
                workflowTags[i] = {
                    id: tag.id,
                    name: tag.name,
                };
            });
            tagLookupPromises.push(lookupPromise);
        }
    }
    await Promise.all(tagLookupPromises);
}
exports.setTagsForImport = setTagsForImport;
//# sourceMappingURL=TagHelpers.js.map