"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWorkflowHooksMain = exports.getWorkflowHooksWorkerMain = exports.getWorkflowHooksWorkerExecuter = exports.getWorkflowHooksIntegrated = exports.getBase = exports.sendMessageToUI = exports.executeWorkflow = exports.getWorkflowData = exports.getRunData = exports.hookFunctionsPreExecute = exports.executeErrorWorkflow = void 0;
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const typeorm_1 = require("typeorm");
const DateUtils_1 = require("typeorm/util/DateUtils");
const config_1 = __importDefault(require("../config"));
const _1 = require(".");
const UserManagementHelper_1 = require("./UserManagement/UserManagementHelper");
const WorkflowHelpers_1 = require("./WorkflowHelpers");
const utils_1 = require("./utils");
const ERROR_TRIGGER_TYPE = config_1.default.getEnv('nodes.errorTriggerType');
function executeErrorWorkflow(workflowData, fullRunData, mode, executionId, retryOf) {
    let pastExecutionUrl;
    if (executionId !== undefined) {
        pastExecutionUrl = `${_1.WebhookHelpers.getWebhookBaseUrl()}execution/${executionId}`;
    }
    if (fullRunData.data.resultData.error !== undefined) {
        let workflowErrorData;
        if (executionId) {
            workflowErrorData = {
                execution: {
                    id: executionId,
                    url: pastExecutionUrl,
                    error: fullRunData.data.resultData.error,
                    lastNodeExecuted: fullRunData.data.resultData.lastNodeExecuted,
                    mode,
                    retryOf,
                },
                workflow: {
                    id: workflowData.id !== undefined ? workflowData.id.toString() : undefined,
                    name: workflowData.name,
                },
            };
        }
        else {
            workflowErrorData = {
                trigger: {
                    error: fullRunData.data.resultData.error,
                    mode,
                },
                workflow: {
                    id: workflowData.id !== undefined ? workflowData.id.toString() : undefined,
                    name: workflowData.name,
                },
            };
        }
        if (workflowData.settings !== undefined &&
            workflowData.settings.errorWorkflow &&
            !(mode === 'error' &&
                workflowData.id &&
                workflowData.settings.errorWorkflow.toString() === workflowData.id.toString())) {
            n8n_workflow_1.LoggerProxy.verbose(`Start external error workflow`, {
                executionId,
                errorWorkflowId: workflowData.settings.errorWorkflow.toString(),
                workflowId: workflowData.id,
            });
            if (!workflowData.id) {
                return;
            }
            (0, UserManagementHelper_1.getWorkflowOwner)(workflowData.id)
                .then((user) => {
                void _1.WorkflowHelpers.executeErrorWorkflow(workflowData.settings.errorWorkflow, workflowErrorData, user);
            })
                .catch((error) => {
                n8n_workflow_1.LoggerProxy.error(`Could not execute ErrorWorkflow for execution ID ${this.executionId} because of error querying the workflow owner`, {
                    executionId,
                    errorWorkflowId: workflowData.settings.errorWorkflow.toString(),
                    workflowId: workflowData.id,
                    error,
                    workflowErrorData,
                });
            });
        }
        else if (mode !== 'error' &&
            workflowData.id !== undefined &&
            workflowData.nodes.some((node) => node.type === ERROR_TRIGGER_TYPE)) {
            n8n_workflow_1.LoggerProxy.verbose(`Start internal error workflow`, { executionId, workflowId: workflowData.id });
            void (0, UserManagementHelper_1.getWorkflowOwner)(workflowData.id).then((user) => {
                void _1.WorkflowHelpers.executeErrorWorkflow(workflowData.id.toString(), workflowErrorData, user);
            });
        }
    }
}
exports.executeErrorWorkflow = executeErrorWorkflow;
let throttling = false;
function pruneExecutionData() {
    if (!throttling) {
        n8n_workflow_1.LoggerProxy.verbose('Pruning execution data from database');
        throttling = true;
        const timeout = config_1.default.getEnv('executions.pruneDataTimeout');
        const maxAge = config_1.default.getEnv('executions.pruneDataMaxAge');
        const date = new Date();
        date.setHours(date.getHours() - maxAge);
        const utcDate = DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(date);
        _1.Db.collections.Execution.delete({ stoppedAt: (0, typeorm_1.LessThanOrEqual)(utcDate) })
            .then((data) => setTimeout(() => {
            throttling = false;
        }, timeout * 1000))
            .catch((error) => {
            throttling = false;
            n8n_workflow_1.LoggerProxy.error(`Failed pruning execution data from database for execution ID ${this.executionId} (hookFunctionsSave)`, {
                ...error,
                executionId: this.executionId,
                sessionId: this.sessionId,
                workflowId: this.workflowData.id,
            });
        });
    }
}
function hookFunctionsPush() {
    return {
        nodeExecuteBefore: [
            async function (nodeName) {
                if (this.sessionId === undefined) {
                    return;
                }
                n8n_workflow_1.LoggerProxy.debug(`Executing hook on node "${nodeName}" (hookFunctionsPush)`, {
                    executionId: this.executionId,
                    sessionId: this.sessionId,
                    workflowId: this.workflowData.id,
                });
                const pushInstance = _1.Push.getInstance();
                pushInstance.send('nodeExecuteBefore', {
                    executionId: this.executionId,
                    nodeName,
                }, this.sessionId);
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName, data) {
                if (this.sessionId === undefined) {
                    return;
                }
                n8n_workflow_1.LoggerProxy.debug(`Executing hook on node "${nodeName}" (hookFunctionsPush)`, {
                    executionId: this.executionId,
                    sessionId: this.sessionId,
                    workflowId: this.workflowData.id,
                });
                const pushInstance = _1.Push.getInstance();
                pushInstance.send('nodeExecuteAfter', {
                    executionId: this.executionId,
                    nodeName,
                    data,
                }, this.sessionId);
            },
        ],
        workflowExecuteBefore: [
            async function () {
                n8n_workflow_1.LoggerProxy.debug(`Executing hook (hookFunctionsPush)`, {
                    executionId: this.executionId,
                    sessionId: this.sessionId,
                    workflowId: this.workflowData.id,
                });
                if (this.sessionId === undefined) {
                    return;
                }
                const pushInstance = _1.Push.getInstance();
                pushInstance.send('executionStarted', {
                    executionId: this.executionId,
                    mode: this.mode,
                    startedAt: new Date(),
                    retryOf: this.retryOf,
                    workflowId: this.workflowData.id,
                    sessionId: this.sessionId,
                    workflowName: this.workflowData.name,
                }, this.sessionId);
            },
        ],
        workflowExecuteAfter: [
            async function (fullRunData, newStaticData) {
                n8n_workflow_1.LoggerProxy.debug(`Executing hook (hookFunctionsPush)`, {
                    executionId: this.executionId,
                    sessionId: this.sessionId,
                    workflowId: this.workflowData.id,
                });
                if (this.sessionId === undefined) {
                    return;
                }
                const pushRunData = {
                    ...fullRunData,
                    data: {
                        ...fullRunData.data,
                        resultData: {
                            ...fullRunData.data.resultData,
                            runData: {},
                        },
                    },
                };
                n8n_workflow_1.LoggerProxy.debug(`Save execution progress to database for execution ID ${this.executionId} `, {
                    executionId: this.executionId,
                    workflowId: this.workflowData.id,
                });
                const sendData = {
                    executionId: this.executionId,
                    data: pushRunData,
                    retryOf: this.retryOf,
                };
                const pushInstance = _1.Push.getInstance();
                pushInstance.send('executionFinished', sendData, this.sessionId);
            },
        ],
    };
}
function hookFunctionsPreExecute(parentProcessMode) {
    const externalHooks = (0, _1.ExternalHooks)();
    return {
        workflowExecuteBefore: [
            async function (workflow) {
                await externalHooks.run('workflow.preExecute', [workflow, this.mode]);
            },
        ],
        nodeExecuteAfter: [
            async function (nodeName, data, executionData) {
                if (this.workflowData.settings !== undefined) {
                    if (this.workflowData.settings.saveExecutionProgress === false) {
                        return;
                    }
                    if (this.workflowData.settings.saveExecutionProgress !== true &&
                        !config_1.default.getEnv('executions.saveExecutionProgress')) {
                        return;
                    }
                }
                else if (!config_1.default.getEnv('executions.saveExecutionProgress')) {
                    return;
                }
                try {
                    n8n_workflow_1.LoggerProxy.debug(`Save execution progress to database for execution ID ${this.executionId} `, { executionId: this.executionId, nodeName });
                    const execution = await _1.Db.collections.Execution.findOne(this.executionId);
                    if (execution === undefined) {
                        return;
                    }
                    const fullExecutionData = _1.ResponseHelper.unflattenExecutionData(execution);
                    if (fullExecutionData.finished) {
                        return;
                    }
                    if (fullExecutionData.data === undefined) {
                        fullExecutionData.data = {
                            startData: {},
                            resultData: {
                                runData: {},
                            },
                            executionData: {
                                contextData: {},
                                nodeExecutionStack: [],
                                waitingExecution: {},
                                waitingExecutionSource: {},
                            },
                        };
                    }
                    if (Array.isArray(fullExecutionData.data.resultData.runData[nodeName])) {
                        fullExecutionData.data.resultData.runData[nodeName].push(data);
                    }
                    else {
                        fullExecutionData.data.resultData.runData[nodeName] = [data];
                    }
                    fullExecutionData.data.executionData = executionData.executionData;
                    fullExecutionData.data.resultData.lastNodeExecuted = nodeName;
                    const flattenedExecutionData = _1.ResponseHelper.flattenExecutionData(fullExecutionData);
                    await _1.Db.collections.Execution.update(this.executionId, flattenedExecutionData);
                }
                catch (err) {
                    n8n_workflow_1.LoggerProxy.error(`Failed saving execution progress to database for execution ID ${this.executionId} (hookFunctionsPreExecute, nodeExecuteAfter)`, {
                        ...err,
                        executionId: this.executionId,
                        sessionId: this.sessionId,
                        workflowId: this.workflowData.id,
                    });
                }
            },
        ],
    };
}
exports.hookFunctionsPreExecute = hookFunctionsPreExecute;
function hookFunctionsSave(parentProcessMode) {
    return {
        nodeExecuteBefore: [],
        nodeExecuteAfter: [],
        workflowExecuteBefore: [],
        workflowExecuteAfter: [
            async function (fullRunData, newStaticData) {
                n8n_workflow_1.LoggerProxy.debug(`Executing hook (hookFunctionsSave)`, {
                    executionId: this.executionId,
                    workflowId: this.workflowData.id,
                });
                if (config_1.default.getEnv('executions.pruneData')) {
                    pruneExecutionData.call(this);
                }
                const isManualMode = [this.mode, parentProcessMode].includes('manual');
                try {
                    if (!isManualMode &&
                        _1.WorkflowHelpers.isWorkflowIdValid(this.workflowData.id) &&
                        newStaticData) {
                        try {
                            await _1.WorkflowHelpers.saveStaticDataById(this.workflowData.id, newStaticData);
                        }
                        catch (e) {
                            n8n_workflow_1.LoggerProxy.error(`There was a problem saving the workflow with id "${this.workflowData.id}" to save changed staticData: "${e.message}" (hookFunctionsSave)`, { executionId: this.executionId, workflowId: this.workflowData.id });
                        }
                    }
                    let saveManualExecutions = config_1.default.getEnv('executions.saveDataManualExecutions');
                    if (this.workflowData.settings !== undefined &&
                        this.workflowData.settings.saveManualExecutions !== undefined) {
                        saveManualExecutions = this.workflowData.settings.saveManualExecutions;
                    }
                    if (isManualMode && !saveManualExecutions && !fullRunData.waitTill) {
                        await _1.Db.collections.Execution.delete(this.executionId);
                        await n8n_core_1.BinaryDataManager.getInstance().markDataForDeletionByExecutionId(this.executionId);
                        return;
                    }
                    let saveDataErrorExecution = config_1.default.getEnv('executions.saveDataOnError');
                    let saveDataSuccessExecution = config_1.default.getEnv('executions.saveDataOnSuccess');
                    if (this.workflowData.settings !== undefined) {
                        saveDataErrorExecution =
                            this.workflowData.settings.saveDataErrorExecution ||
                                saveDataErrorExecution;
                        saveDataSuccessExecution =
                            this.workflowData.settings.saveDataSuccessExecution ||
                                saveDataSuccessExecution;
                    }
                    const workflowDidSucceed = !fullRunData.data.resultData.error;
                    if ((workflowDidSucceed && saveDataSuccessExecution === 'none') ||
                        (!workflowDidSucceed && saveDataErrorExecution === 'none')) {
                        if (!fullRunData.waitTill) {
                            if (!isManualMode) {
                                executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                            }
                            await _1.Db.collections.Execution.delete(this.executionId);
                            await n8n_core_1.BinaryDataManager.getInstance().markDataForDeletionByExecutionId(this.executionId);
                            return;
                        }
                    }
                    const fullExecutionData = {
                        data: fullRunData.data,
                        mode: fullRunData.mode,
                        finished: fullRunData.finished ? fullRunData.finished : false,
                        startedAt: fullRunData.startedAt,
                        stoppedAt: fullRunData.stoppedAt,
                        workflowData: this.workflowData,
                        waitTill: fullRunData.waitTill,
                    };
                    if (this.retryOf !== undefined) {
                        fullExecutionData.retryOf = this.retryOf.toString();
                    }
                    if (this.workflowData.id !== undefined &&
                        _1.WorkflowHelpers.isWorkflowIdValid(this.workflowData.id.toString())) {
                        fullExecutionData.workflowId = this.workflowData.id.toString();
                    }
                    n8n_workflow_1.LoggerProxy.debug(`Save execution data to database for execution ID ${this.executionId}`, {
                        executionId: this.executionId,
                        workflowId: this.workflowData.id,
                        finished: fullExecutionData.finished,
                        stoppedAt: fullExecutionData.stoppedAt,
                    });
                    const executionData = _1.ResponseHelper.flattenExecutionData(fullExecutionData);
                    await _1.Db.collections.Execution.update(this.executionId, executionData);
                    if (fullRunData.finished === true && this.retryOf !== undefined) {
                        await _1.Db.collections.Execution.update(this.retryOf, {
                            retrySuccessId: this.executionId,
                        });
                    }
                    if (!isManualMode) {
                        executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                }
                catch (error) {
                    n8n_workflow_1.LoggerProxy.error(`Failed saving execution data to DB on execution ID ${this.executionId}`, {
                        executionId: this.executionId,
                        workflowId: this.workflowData.id,
                        error,
                    });
                    if (!isManualMode) {
                        executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                }
            },
        ],
    };
}
function hookFunctionsSaveWorker() {
    return {
        nodeExecuteBefore: [],
        nodeExecuteAfter: [],
        workflowExecuteBefore: [],
        workflowExecuteAfter: [
            async function (fullRunData, newStaticData) {
                try {
                    if (_1.WorkflowHelpers.isWorkflowIdValid(this.workflowData.id) && newStaticData) {
                        try {
                            await _1.WorkflowHelpers.saveStaticDataById(this.workflowData.id, newStaticData);
                        }
                        catch (e) {
                            n8n_workflow_1.LoggerProxy.error(`There was a problem saving the workflow with id "${this.workflowData.id}" to save changed staticData: "${e.message}" (workflowExecuteAfter)`, { sessionId: this.sessionId, workflowId: this.workflowData.id });
                        }
                    }
                    const workflowDidSucceed = !fullRunData.data.resultData.error;
                    if (!workflowDidSucceed) {
                        executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                    }
                    const fullExecutionData = {
                        data: fullRunData.data,
                        mode: fullRunData.mode,
                        finished: fullRunData.finished ? fullRunData.finished : false,
                        startedAt: fullRunData.startedAt,
                        stoppedAt: fullRunData.stoppedAt,
                        workflowData: this.workflowData,
                        waitTill: fullRunData.data.waitTill,
                    };
                    if (this.retryOf !== undefined) {
                        fullExecutionData.retryOf = this.retryOf.toString();
                    }
                    if (this.workflowData.id !== undefined &&
                        _1.WorkflowHelpers.isWorkflowIdValid(this.workflowData.id.toString())) {
                        fullExecutionData.workflowId = this.workflowData.id.toString();
                    }
                    const executionData = _1.ResponseHelper.flattenExecutionData(fullExecutionData);
                    await _1.Db.collections.Execution.update(this.executionId, executionData);
                    if (fullRunData.finished === true && this.retryOf !== undefined) {
                        await _1.Db.collections.Execution.update(this.retryOf, {
                            retrySuccessId: this.executionId,
                        });
                    }
                }
                catch (error) {
                    executeErrorWorkflow(this.workflowData, fullRunData, this.mode, this.executionId, this.retryOf);
                }
            },
        ],
    };
}
async function getRunData(workflowData, userId, inputData, parentWorkflowId) {
    var _a, _b, _c;
    const mode = 'integrated';
    const policy = (_b = (_a = workflowData.settings) === null || _a === void 0 ? void 0 : _a.callerPolicy) !== null && _b !== void 0 ? _b : config_1.default.getEnv('workflows.callerPolicyDefaultOption');
    if (policy === 'none') {
        throw new n8n_workflow_1.SubworkflowOperationError(`Target workflow ID ${workflowData.id} may not be called by other workflows.`, 'Please update the settings of the target workflow or ask its owner to do so.');
    }
    if (policy === 'workflowsFromAList' &&
        typeof ((_c = workflowData.settings) === null || _c === void 0 ? void 0 : _c.callerIds) === 'string' &&
        parentWorkflowId !== undefined) {
        const allowedCallerIds = workflowData.settings.callerIds
            .split(',')
            .map((id) => id.trim())
            .filter((id) => id !== '');
        if (!allowedCallerIds.includes(parentWorkflowId)) {
            throw new n8n_workflow_1.SubworkflowOperationError(`Target workflow ID ${workflowData.id} may only be called by a list of workflows, which does not include current workflow ID ${parentWorkflowId}.`, 'Please update the settings of the target workflow or ask its owner to do so.');
        }
    }
    const startingNode = (0, utils_1.findSubworkflowStart)(workflowData.nodes);
    inputData = inputData || [
        {
            json: {},
        },
    ];
    const nodeExecutionStack = [];
    nodeExecutionStack.push({
        node: startingNode,
        data: {
            main: [inputData],
        },
        source: null,
    });
    const runExecutionData = {
        startData: {},
        resultData: {
            runData: {},
        },
        executionData: {
            contextData: {},
            nodeExecutionStack,
            waitingExecution: {},
            waitingExecutionSource: {},
        },
    };
    const runData = {
        executionMode: mode,
        executionData: runExecutionData,
        workflowData,
        userId,
    };
    return runData;
}
exports.getRunData = getRunData;
async function getWorkflowData(workflowInfo, userId, parentWorkflowId, parentWorkflowSettings) {
    if (workflowInfo.id === undefined && workflowInfo.code === undefined) {
        throw new Error(`No information about the workflow to execute found. Please provide either the "id" or "code"!`);
    }
    let workflowData;
    if (workflowInfo.id !== undefined) {
        if (!_1.Db.isInitialized) {
            await _1.Db.init();
        }
        const user = await (0, UserManagementHelper_1.getUserById)(userId);
        let relations = ['workflow', 'workflow.tags'];
        if (config_1.default.getEnv('workflowTagsDisabled')) {
            relations = relations.filter((relation) => relation !== 'workflow.tags');
        }
        const shared = await _1.Db.collections.SharedWorkflow.findOne({
            relations,
            where: (0, WorkflowHelpers_1.whereClause)({
                user,
                entityType: 'workflow',
                entityId: workflowInfo.id,
            }),
        });
        workflowData = shared === null || shared === void 0 ? void 0 : shared.workflow;
        if (workflowData === undefined) {
            throw new Error(`The workflow with the id "${workflowInfo.id}" does not exist.`);
        }
    }
    else {
        workflowData = workflowInfo.code;
        if (workflowData) {
            if (!workflowData.id) {
                workflowData.id = parentWorkflowId;
            }
            if (!workflowData.settings) {
                workflowData.settings = parentWorkflowSettings;
            }
        }
    }
    return workflowData;
}
exports.getWorkflowData = getWorkflowData;
async function executeWorkflow(workflowInfo, additionalData, options) {
    var _a, _b, _c, _d;
    const externalHooks = (0, _1.ExternalHooks)();
    await externalHooks.init();
    const nodeTypes = (0, _1.NodeTypes)();
    const workflowData = (_a = options === null || options === void 0 ? void 0 : options.loadedWorkflowData) !== null && _a !== void 0 ? _a : (await getWorkflowData(workflowInfo, additionalData.userId, options === null || options === void 0 ? void 0 : options.parentWorkflowId, options === null || options === void 0 ? void 0 : options.parentWorkflowSettings));
    const workflowName = workflowData ? workflowData.name : undefined;
    const workflow = new n8n_workflow_1.Workflow({
        id: (_b = workflowData.id) === null || _b === void 0 ? void 0 : _b.toString(),
        name: workflowName,
        nodes: workflowData.nodes,
        connections: workflowData.connections,
        active: workflowData.active,
        nodeTypes,
        staticData: workflowData.staticData,
        settings: workflowData.settings,
    });
    const runData = (_c = options === null || options === void 0 ? void 0 : options.loadedRunData) !== null && _c !== void 0 ? _c : (await getRunData(workflowData, additionalData.userId, options === null || options === void 0 ? void 0 : options.inputData));
    let executionId;
    if ((options === null || options === void 0 ? void 0 : options.parentExecutionId) !== undefined) {
        executionId = options === null || options === void 0 ? void 0 : options.parentExecutionId;
    }
    else {
        executionId =
            (options === null || options === void 0 ? void 0 : options.parentExecutionId) !== undefined
                ? options === null || options === void 0 ? void 0 : options.parentExecutionId
                : await _1.ActiveExecutions.getInstance().add(runData);
    }
    let data;
    try {
        await (0, UserManagementHelper_1.checkPermissionsForExecution)(workflow, additionalData.userId);
        const additionalDataIntegrated = await getBase(additionalData.userId);
        additionalDataIntegrated.hooks = getWorkflowHooksIntegrated(runData.executionMode, executionId, workflowData, { parentProcessMode: additionalData.hooks.mode });
        additionalDataIntegrated.executionId = executionId;
        additionalDataIntegrated.executeWorkflow = additionalData.executeWorkflow;
        let subworkflowTimeout = additionalData.executionTimeoutTimestamp;
        if (((_d = workflowData.settings) === null || _d === void 0 ? void 0 : _d.executionTimeout) !== undefined &&
            workflowData.settings.executionTimeout > 0) {
            subworkflowTimeout = Math.min(additionalData.executionTimeoutTimestamp || Number.MAX_SAFE_INTEGER, Date.now() + workflowData.settings.executionTimeout * 1000);
        }
        additionalDataIntegrated.executionTimeoutTimestamp = subworkflowTimeout;
        const runExecutionData = runData.executionData;
        const workflowExecute = new n8n_core_1.WorkflowExecute(additionalDataIntegrated, runData.executionMode, runExecutionData);
        if ((options === null || options === void 0 ? void 0 : options.parentExecutionId) !== undefined) {
            return {
                startedAt: new Date(),
                workflow,
                workflowExecute,
            };
        }
        data = await workflowExecute.processRunExecutionData(workflow);
    }
    catch (error) {
        const fullRunData = {
            data: {
                resultData: {
                    error,
                    runData: {},
                },
            },
            finished: false,
            mode: 'integrated',
            startedAt: new Date(),
            stoppedAt: new Date(),
        };
        const fullExecutionData = {
            data: fullRunData.data,
            mode: fullRunData.mode,
            finished: fullRunData.finished ? fullRunData.finished : false,
            startedAt: fullRunData.startedAt,
            stoppedAt: fullRunData.stoppedAt,
            workflowData,
        };
        if (workflowData.id) {
            fullExecutionData.workflowId = workflowData.id;
        }
        const executionData = _1.ResponseHelper.flattenExecutionData(fullExecutionData);
        await _1.Db.collections.Execution.update(executionId, executionData);
        throw {
            ...error,
            stack: error.stack,
        };
    }
    await externalHooks.run('workflow.postExecute', [data, workflowData, executionId]);
    void _1.InternalHooksManager.getInstance().onWorkflowPostExecute(executionId, workflowData, data, additionalData.userId);
    if (data.finished === true) {
        await _1.ActiveExecutions.getInstance().remove(executionId, data);
        const returnData = _1.WorkflowHelpers.getDataLastExecutedNodeData(data);
        return returnData.data.main;
    }
    await _1.ActiveExecutions.getInstance().remove(executionId, data);
    const { error } = data.data.resultData;
    throw {
        ...error,
        stack: error.stack,
    };
}
exports.executeWorkflow = executeWorkflow;
function sendMessageToUI(source, messages) {
    if (this.sessionId === undefined) {
        return;
    }
    try {
        const pushInstance = _1.Push.getInstance();
        pushInstance.send('sendConsoleMessage', {
            source: `[Node: "${source}"]`,
            messages,
        }, this.sessionId);
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.warn(`There was a problem sending message to UI: ${error.message}`);
    }
}
exports.sendMessageToUI = sendMessageToUI;
async function getBase(userId, currentNodeParameters, executionTimeoutTimestamp) {
    const urlBaseWebhook = _1.WebhookHelpers.getWebhookBaseUrl();
    const timezone = config_1.default.getEnv('generic.timezone');
    const webhookBaseUrl = urlBaseWebhook + config_1.default.getEnv('endpoints.webhook');
    const webhookWaitingBaseUrl = urlBaseWebhook + config_1.default.getEnv('endpoints.webhookWaiting');
    const webhookTestBaseUrl = urlBaseWebhook + config_1.default.getEnv('endpoints.webhookTest');
    const encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
    return {
        credentialsHelper: new _1.CredentialsHelper(encryptionKey),
        encryptionKey,
        executeWorkflow,
        restApiUrl: urlBaseWebhook + config_1.default.getEnv('endpoints.rest'),
        timezone,
        webhookBaseUrl,
        webhookWaitingBaseUrl,
        webhookTestBaseUrl,
        currentNodeParameters,
        executionTimeoutTimestamp,
        userId,
    };
}
exports.getBase = getBase;
function getWorkflowHooksIntegrated(mode, executionId, workflowData, optionalParameters) {
    optionalParameters = optionalParameters || {};
    const hookFunctions = hookFunctionsSave(optionalParameters.parentProcessMode);
    const preExecuteFunctions = hookFunctionsPreExecute(optionalParameters.parentProcessMode);
    for (const key of Object.keys(preExecuteFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
    }
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData, optionalParameters);
}
exports.getWorkflowHooksIntegrated = getWorkflowHooksIntegrated;
function getWorkflowHooksWorkerExecuter(mode, executionId, workflowData, optionalParameters) {
    optionalParameters = optionalParameters || {};
    const hookFunctions = hookFunctionsSaveWorker();
    const preExecuteFunctions = hookFunctionsPreExecute(optionalParameters.parentProcessMode);
    for (const key of Object.keys(preExecuteFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
    }
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData, optionalParameters);
}
exports.getWorkflowHooksWorkerExecuter = getWorkflowHooksWorkerExecuter;
function getWorkflowHooksWorkerMain(mode, executionId, workflowData, optionalParameters) {
    optionalParameters = optionalParameters || {};
    const hookFunctions = hookFunctionsPush();
    const preExecuteFunctions = hookFunctionsPreExecute(optionalParameters.parentProcessMode);
    for (const key of Object.keys(preExecuteFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
    }
    hookFunctions.nodeExecuteBefore = [];
    hookFunctions.nodeExecuteAfter = [];
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, mode, executionId, workflowData, optionalParameters);
}
exports.getWorkflowHooksWorkerMain = getWorkflowHooksWorkerMain;
function getWorkflowHooksMain(data, executionId, isMainProcess = false) {
    const hookFunctions = hookFunctionsSave();
    const pushFunctions = hookFunctionsPush();
    for (const key of Object.keys(pushFunctions)) {
        if (hookFunctions[key] === undefined) {
            hookFunctions[key] = [];
        }
        hookFunctions[key].push.apply(hookFunctions[key], pushFunctions[key]);
    }
    if (isMainProcess) {
        const preExecuteFunctions = hookFunctionsPreExecute();
        for (const key of Object.keys(preExecuteFunctions)) {
            if (hookFunctions[key] === undefined) {
                hookFunctions[key] = [];
            }
            hookFunctions[key].push.apply(hookFunctions[key], preExecuteFunctions[key]);
        }
    }
    return new n8n_workflow_1.WorkflowHooks(hookFunctions, data.executionMode, executionId, data.workflowData, {
        sessionId: data.sessionId,
        retryOf: data.retryOf,
    });
}
exports.getWorkflowHooksMain = getWorkflowHooksMain;
//# sourceMappingURL=WorkflowExecuteAdditionalData.js.map