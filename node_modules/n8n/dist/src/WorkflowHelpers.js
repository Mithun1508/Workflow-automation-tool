"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateWorkflowCredentialUsage = exports.getNodesWithInaccessibleCreds = exports.generateFailedExecutionFromError = exports.isBelowOnboardingThreshold = exports.getSharedWorkflowIds = exports.whereClause = exports.replaceInvalidCredentials = exports.addNodeIds = exports.getStaticDataById = exports.saveStaticDataById = exports.saveStaticData = exports.getNeededNodeTypes = exports.getCredentialsDataByNodes = exports.getCredentialsDataWithParents = exports.getNodeTypeData = exports.getAllCredentalsTypeData = exports.getAllNodeTypeData = exports.executeErrorWorkflow = exports.isWorkflowIdValid = exports.getDataLastExecutedNodeData = void 0;
const typeorm_1 = require("typeorm");
const n8n_workflow_1 = require("n8n-workflow");
const uuid_1 = require("uuid");
const _1 = require(".");
const config_1 = __importDefault(require("../config"));
const UserManagementHelper_1 = require("./UserManagement/UserManagementHelper");
const ERROR_TRIGGER_TYPE = config_1.default.getEnv('nodes.errorTriggerType');
function getDataLastExecutedNodeData(inputData) {
    const { runData, pinData = {} } = inputData.data.resultData;
    const { lastNodeExecuted } = inputData.data.resultData;
    if (lastNodeExecuted === undefined) {
        return undefined;
    }
    if (runData[lastNodeExecuted] === undefined) {
        return undefined;
    }
    const lastNodeRunData = runData[lastNodeExecuted][runData[lastNodeExecuted].length - 1];
    let lastNodePinData = pinData[lastNodeExecuted];
    if (lastNodePinData) {
        if (!Array.isArray(lastNodePinData))
            lastNodePinData = [lastNodePinData];
        const itemsPerRun = lastNodePinData.map((item, index) => {
            return { json: item, pairedItem: { item: index } };
        });
        return {
            startTime: 0,
            executionTime: 0,
            data: { main: [itemsPerRun] },
            source: lastNodeRunData.source,
        };
    }
    return lastNodeRunData;
}
exports.getDataLastExecutedNodeData = getDataLastExecutedNodeData;
function isWorkflowIdValid(id) {
    if (typeof id === 'string') {
        id = parseInt(id, 10);
    }
    if (isNaN(id)) {
        return false;
    }
    return true;
}
exports.isWorkflowIdValid = isWorkflowIdValid;
async function executeErrorWorkflow(workflowId, workflowErrorData, runningUser) {
    var _a;
    try {
        let workflowData;
        if (workflowId.toString() !== ((_a = workflowErrorData.workflow.id) === null || _a === void 0 ? void 0 : _a.toString())) {
            const user = await (0, UserManagementHelper_1.getWorkflowOwner)(workflowErrorData.workflow.id);
            if (user.globalRole.name === 'owner') {
                workflowData = await _1.Db.collections.Workflow.findOne({ id: Number(workflowId) });
            }
            else {
                const sharedWorkflowData = await _1.Db.collections.SharedWorkflow.findOne({
                    where: {
                        workflow: { id: workflowId },
                        user,
                    },
                    relations: ['workflow'],
                });
                if (sharedWorkflowData) {
                    workflowData = sharedWorkflowData.workflow;
                }
            }
        }
        else {
            workflowData = await _1.Db.collections.Workflow.findOne({ id: Number(workflowId) });
        }
        if (workflowData === undefined) {
            n8n_workflow_1.LoggerProxy.error(`Calling Error Workflow for "${workflowErrorData.workflow.id}". Could not find error workflow "${workflowId}"`, { workflowId });
            return;
        }
        const user = await (0, UserManagementHelper_1.getWorkflowOwner)(workflowId);
        if (user.id !== runningUser.id) {
            n8n_workflow_1.LoggerProxy.warn(`An attempt to execute workflow ID ${workflowId} as error workflow was blocked due to wrong permission`);
            return;
        }
        const executionMode = 'error';
        const nodeTypes = (0, _1.NodeTypes)();
        const workflowInstance = new n8n_workflow_1.Workflow({
            id: workflowId,
            name: workflowData.name,
            nodeTypes,
            nodes: workflowData.nodes,
            connections: workflowData.connections,
            active: workflowData.active,
            staticData: workflowData.staticData,
            settings: workflowData.settings,
        });
        let node;
        let workflowStartNode;
        for (const nodeName of Object.keys(workflowInstance.nodes)) {
            node = workflowInstance.nodes[nodeName];
            if (node.type === ERROR_TRIGGER_TYPE) {
                workflowStartNode = node;
            }
        }
        if (workflowStartNode === undefined) {
            n8n_workflow_1.LoggerProxy.error(`Calling Error Workflow for "${workflowErrorData.workflow.id}". Could not find "${ERROR_TRIGGER_TYPE}" in workflow "${workflowId}"`);
            return;
        }
        const nodeExecutionStack = [];
        nodeExecutionStack.push({
            node: workflowStartNode,
            data: {
                main: [
                    [
                        {
                            json: workflowErrorData,
                        },
                    ],
                ],
            },
            source: null,
        });
        const runExecutionData = {
            startData: {},
            resultData: {
                runData: {},
            },
            executionData: {
                contextData: {},
                nodeExecutionStack,
                waitingExecution: {},
                waitingExecutionSource: {},
            },
        };
        const runData = {
            executionMode,
            executionData: runExecutionData,
            workflowData,
            userId: user.id,
        };
        const workflowRunner = new _1.WorkflowRunner();
        await workflowRunner.run(runData);
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.error(`Calling Error Workflow for "${workflowErrorData.workflow.id}": "${error.message}"`, { workflowId: workflowErrorData.workflow.id });
    }
}
exports.executeErrorWorkflow = executeErrorWorkflow;
function getAllNodeTypeData() {
    const nodeTypes = (0, _1.NodeTypes)();
    const returnData = {};
    for (const nodeTypeName of Object.keys(nodeTypes.nodeTypes)) {
        if (nodeTypes.nodeTypes[nodeTypeName] === undefined) {
            throw new Error(`The NodeType "${nodeTypeName}" could not be found!`);
        }
        returnData[nodeTypeName] = {
            className: nodeTypes.nodeTypes[nodeTypeName].type.constructor.name,
            sourcePath: nodeTypes.nodeTypes[nodeTypeName].sourcePath,
        };
    }
    return returnData;
}
exports.getAllNodeTypeData = getAllNodeTypeData;
function getAllCredentalsTypeData() {
    const credentialTypes = (0, _1.CredentialTypes)();
    const returnData = {};
    for (const credentialTypeName of Object.keys(credentialTypes.credentialTypes)) {
        if (credentialTypes.credentialTypes[credentialTypeName] === undefined) {
            throw new Error(`The CredentialType "${credentialTypeName}" could not be found!`);
        }
        returnData[credentialTypeName] = {
            className: credentialTypes.credentialTypes[credentialTypeName].type.constructor.name,
            sourcePath: credentialTypes.credentialTypes[credentialTypeName].sourcePath,
        };
    }
    return returnData;
}
exports.getAllCredentalsTypeData = getAllCredentalsTypeData;
function getNodeTypeData(nodes) {
    const nodeTypes = (0, _1.NodeTypes)();
    const neededNodeTypes = getNeededNodeTypes(nodes);
    const returnData = {};
    for (const nodeTypeName of neededNodeTypes) {
        if (nodeTypes.nodeTypes[nodeTypeName.type] === undefined) {
            throw new Error(`The NodeType "${nodeTypeName.type}" could not be found!`);
        }
        returnData[nodeTypeName.type] = {
            className: nodeTypes.nodeTypes[nodeTypeName.type].type.constructor.name,
            sourcePath: nodeTypes.nodeTypes[nodeTypeName.type].sourcePath,
        };
    }
    return returnData;
}
exports.getNodeTypeData = getNodeTypeData;
function getCredentialsDataWithParents(type) {
    const credentialTypes = (0, _1.CredentialTypes)();
    const credentialType = credentialTypes.getByName(type);
    const credentialTypeData = {};
    credentialTypeData[type] = {
        className: credentialTypes.credentialTypes[type].type.constructor.name,
        sourcePath: credentialTypes.credentialTypes[type].sourcePath,
    };
    if (credentialType === undefined || credentialType.extends === undefined) {
        return credentialTypeData;
    }
    for (const typeName of credentialType.extends) {
        if (credentialTypeData[typeName] !== undefined) {
            continue;
        }
        credentialTypeData[typeName] = {
            className: credentialTypes.credentialTypes[typeName].type.constructor.name,
            sourcePath: credentialTypes.credentialTypes[typeName].sourcePath,
        };
        Object.assign(credentialTypeData, getCredentialsDataWithParents(typeName));
    }
    return credentialTypeData;
}
exports.getCredentialsDataWithParents = getCredentialsDataWithParents;
function getCredentialsDataByNodes(nodes) {
    const credentialTypeData = {};
    for (const node of nodes) {
        const credentialsUsedByThisNode = node.credentials;
        if (credentialsUsedByThisNode) {
            for (const credentialType of Object.keys(credentialsUsedByThisNode)) {
                if (credentialTypeData[credentialType] !== undefined) {
                    continue;
                }
                Object.assign(credentialTypeData, getCredentialsDataWithParents(credentialType));
            }
        }
    }
    return credentialTypeData;
}
exports.getCredentialsDataByNodes = getCredentialsDataByNodes;
function getNeededNodeTypes(nodes) {
    const neededNodeTypes = [];
    for (const node of nodes) {
        if (neededNodeTypes.find((neededNodes) => node.type === neededNodes.type) === undefined) {
            neededNodeTypes.push({ type: node.type, version: node.typeVersion });
        }
    }
    return neededNodeTypes;
}
exports.getNeededNodeTypes = getNeededNodeTypes;
async function saveStaticData(workflow) {
    if (workflow.staticData.__dataChanged === true) {
        if (isWorkflowIdValid(workflow.id)) {
            try {
                await saveStaticDataById(workflow.id, workflow.staticData);
                workflow.staticData.__dataChanged = false;
            }
            catch (e) {
                n8n_workflow_1.LoggerProxy.error(`There was a problem saving the workflow with id "${workflow.id}" to save changed staticData: "${e.message}"`, { workflowId: workflow.id });
            }
        }
    }
}
exports.saveStaticData = saveStaticData;
async function saveStaticDataById(workflowId, newStaticData) {
    await _1.Db.collections.Workflow.update(workflowId, {
        staticData: newStaticData,
    });
}
exports.saveStaticDataById = saveStaticDataById;
async function getStaticDataById(workflowId) {
    const workflowData = await _1.Db.collections.Workflow.findOne(workflowId, {
        select: ['staticData'],
    });
    if (workflowData === undefined) {
        return {};
    }
    return workflowData.staticData || {};
}
exports.getStaticDataById = getStaticDataById;
function addNodeIds(workflow) {
    const { nodes } = workflow;
    if (!nodes)
        return;
    nodes.forEach((node) => {
        if (!node.id) {
            node.id = (0, uuid_1.v4)();
        }
    });
}
exports.addNodeIds = addNodeIds;
async function replaceInvalidCredentials(workflow) {
    const { nodes } = workflow;
    if (!nodes)
        return workflow;
    const credentialsByName = {};
    const credentialsById = {};
    for (const node of nodes) {
        if (!node.credentials || node.disabled) {
            continue;
        }
        const allNodeCredentials = Object.entries(node.credentials);
        for (const [nodeCredentialType, nodeCredentials] of allNodeCredentials) {
            if (typeof nodeCredentials === 'string' || nodeCredentials.id === null) {
                const name = typeof nodeCredentials === 'string' ? nodeCredentials : nodeCredentials.name;
                if (!credentialsByName[nodeCredentialType]) {
                    credentialsByName[nodeCredentialType] = {};
                }
                if (credentialsByName[nodeCredentialType][name] === undefined) {
                    const credentials = await _1.Db.collections.Credentials.find({
                        name,
                        type: nodeCredentialType,
                    });
                    if ((credentials === null || credentials === void 0 ? void 0 : credentials.length) === 1) {
                        credentialsByName[nodeCredentialType][name] = {
                            id: credentials[0].id.toString(),
                            name: credentials[0].name,
                        };
                        node.credentials[nodeCredentialType] = credentialsByName[nodeCredentialType][name];
                        continue;
                    }
                    credentialsByName[nodeCredentialType][name] = {
                        id: null,
                        name,
                    };
                }
                else {
                    node.credentials[nodeCredentialType] = credentialsByName[nodeCredentialType][name];
                }
                continue;
            }
            if (!credentialsById[nodeCredentialType]) {
                credentialsById[nodeCredentialType] = {};
            }
            if (credentialsById[nodeCredentialType][nodeCredentials.id] === undefined) {
                const credentials = await _1.Db.collections.Credentials.findOne({
                    id: nodeCredentials.id,
                    type: nodeCredentialType,
                });
                if (credentials) {
                    credentialsById[nodeCredentialType][nodeCredentials.id] = {
                        id: credentials.id.toString(),
                        name: credentials.name,
                    };
                    node.credentials[nodeCredentialType] =
                        credentialsById[nodeCredentialType][nodeCredentials.id];
                    continue;
                }
                const credsByName = await _1.Db.collections.Credentials.find({
                    name: nodeCredentials.name,
                    type: nodeCredentialType,
                });
                if ((credsByName === null || credsByName === void 0 ? void 0 : credsByName.length) === 1) {
                    credentialsById[nodeCredentialType][credsByName[0].id] = {
                        id: credsByName[0].id.toString(),
                        name: credsByName[0].name,
                    };
                    node.credentials[nodeCredentialType] =
                        credentialsById[nodeCredentialType][credsByName[0].id];
                    continue;
                }
                credentialsById[nodeCredentialType][nodeCredentials.id] = nodeCredentials;
                continue;
            }
            node.credentials[nodeCredentialType] =
                credentialsById[nodeCredentialType][nodeCredentials.id];
        }
    }
    return workflow;
}
exports.replaceInvalidCredentials = replaceInvalidCredentials;
function whereClause({ user, entityType, entityId = '', }) {
    const where = entityId ? { [entityType]: { id: entityId } } : {};
    if (user.globalRole.name !== 'owner') {
        where.user = { id: user.id };
    }
    return where;
}
exports.whereClause = whereClause;
async function getSharedWorkflowIds(user) {
    const sharedWorkflows = await _1.Db.collections.SharedWorkflow.find({
        relations: ['workflow'],
        where: whereClause({
            user,
            entityType: 'workflow',
        }),
    });
    return sharedWorkflows.map(({ workflow }) => workflow.id);
}
exports.getSharedWorkflowIds = getSharedWorkflowIds;
async function isBelowOnboardingThreshold(user) {
    let belowThreshold = true;
    const skippedTypes = ['n8n-nodes-base.start', 'n8n-nodes-base.stickyNote'];
    const workflowOwnerRole = await _1.Db.collections.Role.findOne({
        name: 'owner',
        scope: 'workflow',
    });
    const ownedWorkflowsIds = await _1.Db.collections.SharedWorkflow.find({
        user,
        role: workflowOwnerRole,
    }).then((ownedWorkflows) => ownedWorkflows.map((wf) => wf.workflowId));
    if (ownedWorkflowsIds.length > 15) {
        belowThreshold = false;
    }
    else {
        const workflows = await _1.Db.collections.Workflow.find({
            where: { id: (0, typeorm_1.In)(ownedWorkflowsIds) },
            select: ['nodes'],
        });
        const validWorkflowCount = workflows.reduce((counter, workflow) => {
            if (counter <= 2 && workflow.nodes.length > 2) {
                const nodes = workflow.nodes.filter((node) => !skippedTypes.includes(node.type));
                if (nodes.length >= 2) {
                    return counter + 1;
                }
            }
            return counter;
        }, 0);
        belowThreshold = validWorkflowCount <= 2;
    }
    if (!belowThreshold) {
        void _1.Db.collections.User.update(user.id, { settings: { isOnboarded: true } });
    }
    return belowThreshold;
}
exports.isBelowOnboardingThreshold = isBelowOnboardingThreshold;
function generateFailedExecutionFromError(mode, error, node) {
    return {
        data: {
            startData: {
                destinationNode: node.name,
                runNodeFilter: [node.name],
            },
            resultData: {
                error,
                runData: {
                    [node.name]: [
                        {
                            startTime: 0,
                            executionTime: 0,
                            error,
                            source: [],
                        },
                    ],
                },
                lastNodeExecuted: node.name,
            },
            executionData: {
                contextData: {},
                nodeExecutionStack: [
                    {
                        node,
                        data: {},
                        source: null,
                    },
                ],
                waitingExecution: {},
                waitingExecutionSource: {},
            },
        },
        finished: false,
        mode,
        startedAt: new Date(),
        stoppedAt: new Date(),
    };
}
exports.generateFailedExecutionFromError = generateFailedExecutionFromError;
function getNodesWithInaccessibleCreds(workflow, userCredIds) {
    if (!workflow.nodes) {
        return [];
    }
    return workflow.nodes.filter((node) => {
        if (!node.credentials)
            return false;
        const allUsedCredentials = Object.values(node.credentials);
        const allUsedCredentialIds = allUsedCredentials.map((nodeCred) => { var _a; return (_a = nodeCred.id) === null || _a === void 0 ? void 0 : _a.toString(); });
        return allUsedCredentialIds.some((nodeCredId) => nodeCredId && !userCredIds.includes(nodeCredId));
    });
}
exports.getNodesWithInaccessibleCreds = getNodesWithInaccessibleCreds;
function validateWorkflowCredentialUsage(newWorkflowVersion, previousWorkflowVersion, credentialsUserHasAccessTo) {
    const allowedCredentialIds = credentialsUserHasAccessTo.map((cred) => cred.id.toString());
    const nodesWithCredentialsUserDoesNotHaveAccessTo = getNodesWithInaccessibleCreds(newWorkflowVersion, allowedCredentialIds);
    if (nodesWithCredentialsUserDoesNotHaveAccessTo.length === 0) {
        return newWorkflowVersion;
    }
    const previouslyExistingNodeIds = previousWorkflowVersion.nodes.map((node) => node.id);
    const isTamperingAttempt = (inaccessibleCredNodeId) => !previouslyExistingNodeIds.includes(inaccessibleCredNodeId);
    nodesWithCredentialsUserDoesNotHaveAccessTo.forEach((node) => {
        if (isTamperingAttempt(node.id)) {
            n8n_workflow_1.LoggerProxy.info('Blocked workflow update due to tampering attempt', {
                nodeType: node.type,
                nodeName: node.name,
                nodeId: node.id,
                nodeCredentials: node.credentials,
            });
            throw new Error('Workflow contains new nodes with credentials the user does not have access to');
        }
        const nodeIdx = newWorkflowVersion.nodes.findIndex((newWorkflowNode) => newWorkflowNode.id === node.id);
        n8n_workflow_1.LoggerProxy.debug('Replacing node with previous version when saving updated workflow', {
            nodeType: node.type,
            nodeName: node.name,
            nodeId: node.id,
        });
        newWorkflowVersion.nodes[nodeIdx] = previousWorkflowVersion.nodes.find((previousNode) => previousNode.id === node.id);
    });
    return newWorkflowVersion;
}
exports.validateWorkflowCredentialUsage = validateWorkflowCredentialUsage;
//# sourceMappingURL=WorkflowHelpers.js.map