"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeTypesController = void 0;
const express_1 = __importDefault(require("express"));
const promises_1 = require("fs/promises");
const lodash_1 = __importDefault(require("lodash"));
const n8n_workflow_1 = require("n8n-workflow");
const __1 = require("..");
const config_1 = __importDefault(require("../../config"));
const TranslationHelpers_1 = require("../TranslationHelpers");
function isOAuth(credType) {
    return (Array.isArray(credType.extends) &&
        credType.extends.some((parentType) => ['oAuth2Api', 'googleOAuth2Api', 'oAuth1Api'].includes(parentType)));
}
function supportsProxyAuth(description) {
    if (!description.credentials)
        return false;
    const credentialTypes = (0, __1.CredentialTypes)();
    return description.credentials.some(({ name }) => {
        const credType = credentialTypes.getByName(name);
        if (credType.authenticate !== undefined)
            return true;
        return isOAuth(credType);
    });
}
const CUSTOM_API_CALL_NAME = 'Custom API Call';
const CUSTOM_API_CALL_KEY = '__CUSTOM_API_CALL__';
function injectCustomApiCallOption(description) {
    if (!supportsProxyAuth(description))
        return description;
    description.properties.forEach((p) => {
        if (['resource', 'operation'].includes(p.name) &&
            Array.isArray(p.options) &&
            p.options[p.options.length - 1].name !== CUSTOM_API_CALL_NAME) {
            p.options.push({
                name: CUSTOM_API_CALL_NAME,
                value: CUSTOM_API_CALL_KEY,
            });
        }
        return p;
    });
    return description;
}
exports.nodeTypesController = express_1.default.Router();
exports.nodeTypesController.get('/', __1.ResponseHelper.send(async (req) => {
    const returnData = [];
    const onlyLatest = req.query.onlyLatest === 'true';
    const nodeTypes = (0, __1.NodeTypes)();
    const allNodes = nodeTypes.getAll();
    const getNodeDescription = (nodeType) => {
        const nodeInfo = { ...nodeType.description };
        if (req.query.includeProperties !== 'true') {
            delete nodeInfo.properties;
        }
        return nodeInfo;
    };
    if (onlyLatest) {
        allNodes.forEach((nodeData) => {
            const nodeType = n8n_workflow_1.NodeHelpers.getVersionedNodeType(nodeData);
            const nodeInfo = getNodeDescription(nodeType);
            returnData.push(nodeInfo);
        });
    }
    else {
        allNodes.forEach((nodeData) => {
            const allNodeTypes = n8n_workflow_1.NodeHelpers.getVersionedNodeTypeAll(nodeData);
            allNodeTypes.forEach((element) => {
                const nodeInfo = getNodeDescription(element);
                returnData.push(nodeInfo);
            });
        });
    }
    return returnData;
}));
exports.nodeTypesController.post('/', __1.ResponseHelper.send(async (req) => {
    const nodeInfos = lodash_1.default.get(req, 'body.nodeInfos', []);
    const defaultLocale = config_1.default.getEnv('defaultLocale');
    if (defaultLocale === 'en') {
        return nodeInfos.reduce((acc, { name, version }) => {
            const { description } = (0, __1.NodeTypes)().getByNameAndVersion(name, version);
            acc.push(injectCustomApiCallOption(description));
            return acc;
        }, []);
    }
    async function populateTranslation(name, version, nodeTypes) {
        const { description, sourcePath } = (0, __1.NodeTypes)().getWithSourcePath(name, version);
        const translationPath = await (0, TranslationHelpers_1.getNodeTranslationPath)({
            nodeSourcePath: sourcePath,
            longNodeType: description.name,
            locale: defaultLocale,
        });
        try {
            const translation = await (0, promises_1.readFile)(translationPath, 'utf8');
            description.translation = JSON.parse(translation);
        }
        catch (error) {
        }
        nodeTypes.push(injectCustomApiCallOption(description));
    }
    const nodeTypes = [];
    const promises = nodeInfos.map(async ({ name, version }) => populateTranslation(name, version, nodeTypes));
    await Promise.all(promises);
    return nodeTypes;
}));
//# sourceMappingURL=nodeTypes.api.js.map