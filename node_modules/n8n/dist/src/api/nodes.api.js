"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodesController = void 0;
const express_1 = __importDefault(require("express"));
const __1 = require("..");
const config_1 = __importDefault(require("../../config"));
const helpers_1 = require("../CommunityNodes/helpers");
const packageModel_1 = require("../CommunityNodes/packageModel");
const constants_1 = require("../constants");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const { PACKAGE_NOT_INSTALLED, PACKAGE_NAME_NOT_PROVIDED } = constants_1.RESPONSE_ERROR_MESSAGES;
exports.nodesController = express_1.default.Router();
exports.nodesController.use((req, res, next) => {
    if (!(0, UserManagementHelper_1.isAuthenticatedRequest)(req) || req.user.globalRole.name !== 'owner') {
        res.status(403).json({ status: 'error', message: 'Unauthorized' });
        return;
    }
    next();
});
exports.nodesController.use((req, res, next) => {
    if (config_1.default.getEnv('executions.mode') === 'queue' && req.method !== 'GET') {
        res.status(400).json({
            status: 'error',
            message: 'Package management is disabled when running in "queue" mode',
        });
        return;
    }
    next();
});
exports.nodesController.post('/', __1.ResponseHelper.send(async (req) => {
    const { name } = req.body;
    if (!name) {
        throw new __1.ResponseHelper.ResponseError(PACKAGE_NAME_NOT_PROVIDED, undefined, 400);
    }
    let parsed;
    try {
        parsed = (0, helpers_1.parseNpmPackageName)(name);
    }
    catch (error) {
        throw new __1.ResponseHelper.ResponseError(error instanceof Error ? error.message : 'Failed to parse package name', undefined, 400);
    }
    if (parsed.packageName === constants_1.STARTER_TEMPLATE_NAME) {
        throw new __1.ResponseHelper.ResponseError([
            `Package "${parsed.packageName}" is only a template`,
            'Please enter an actual package to install',
        ].join('.'), undefined, 400);
    }
    const isInstalled = await (0, packageModel_1.isPackageInstalled)(parsed.packageName);
    const hasLoaded = (0, helpers_1.hasPackageLoaded)(name);
    if (isInstalled && hasLoaded) {
        throw new __1.ResponseHelper.ResponseError([
            `Package "${parsed.packageName}" is already installed`,
            'To update it, click the corresponding button in the UI',
        ].join('.'), undefined, 400);
    }
    const packageStatus = await (0, helpers_1.checkNpmPackageStatus)(name);
    if (packageStatus.status !== 'OK') {
        throw new __1.ResponseHelper.ResponseError(`Package "${name}" is banned so it cannot be installed`, undefined, 400);
    }
    let installedPackage;
    try {
        installedPackage = await (0, __1.LoadNodesAndCredentials)().loadNpmModule(parsed.packageName, parsed.version);
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : constants_1.UNKNOWN_FAILURE_REASON;
        void __1.InternalHooksManager.getInstance().onCommunityPackageInstallFinished({
            user_id: req.user.id,
            input_string: name,
            package_name: parsed.packageName,
            success: false,
            package_version: parsed.version,
            failure_reason: errorMessage,
        });
        const message = [`Error loading package "${name}"`, errorMessage].join(':');
        const clientError = error instanceof Error ? (0, helpers_1.isClientError)(error) : false;
        throw new __1.ResponseHelper.ResponseError(message, undefined, clientError ? 400 : 500);
    }
    if (!hasLoaded)
        (0, helpers_1.removePackageFromMissingList)(name);
    const pushInstance = __1.Push.getInstance();
    installedPackage.installedNodes.forEach((node) => {
        pushInstance.send('reloadNodeType', {
            name: node.type,
            version: node.latestVersion,
        });
    });
    void __1.InternalHooksManager.getInstance().onCommunityPackageInstallFinished({
        user_id: req.user.id,
        input_string: name,
        package_name: parsed.packageName,
        success: true,
        package_version: parsed.version,
        package_node_names: installedPackage.installedNodes.map((node) => node.name),
        package_author: installedPackage.authorName,
        package_author_email: installedPackage.authorEmail,
    });
    return installedPackage;
}));
exports.nodesController.get('/', __1.ResponseHelper.send(async () => {
    const installedPackages = await (0, packageModel_1.getAllInstalledPackages)();
    if (installedPackages.length === 0)
        return [];
    let pendingUpdates;
    try {
        const command = ['npm', 'outdated', '--json'].join(' ');
        await (0, helpers_1.executeCommand)(command, { doNotHandleError: true });
    }
    catch (error) {
        if ((0, helpers_1.isNpmError)(error) && error.code === 1) {
            pendingUpdates = JSON.parse(error.stdout);
        }
    }
    let hydratedPackages = (0, helpers_1.matchPackagesWithUpdates)(installedPackages, pendingUpdates);
    try {
        const missingPackages = config_1.default.get('nodes.packagesMissing');
        if (missingPackages) {
            hydratedPackages = (0, helpers_1.matchMissingPackages)(hydratedPackages, missingPackages);
        }
    }
    catch (_) {
    }
    return hydratedPackages;
}));
exports.nodesController.delete('/', __1.ResponseHelper.send(async (req) => {
    const { name } = req.query;
    if (!name) {
        throw new __1.ResponseHelper.ResponseError(PACKAGE_NAME_NOT_PROVIDED, undefined, 400);
    }
    try {
        (0, helpers_1.sanitizeNpmPackageName)(name);
    }
    catch (error) {
        const message = error instanceof Error ? error.message : constants_1.UNKNOWN_FAILURE_REASON;
        throw new __1.ResponseHelper.ResponseError(message, undefined, 400);
    }
    const installedPackage = await (0, packageModel_1.findInstalledPackage)(name);
    if (!installedPackage) {
        throw new __1.ResponseHelper.ResponseError(PACKAGE_NOT_INSTALLED, undefined, 400);
    }
    try {
        await (0, __1.LoadNodesAndCredentials)().removeNpmModule(name, installedPackage);
    }
    catch (error) {
        const message = [
            `Error removing package "${name}"`,
            error instanceof Error ? error.message : constants_1.UNKNOWN_FAILURE_REASON,
        ].join(':');
        throw new __1.ResponseHelper.ResponseError(message, undefined, 500);
    }
    const pushInstance = __1.Push.getInstance();
    installedPackage.installedNodes.forEach((node) => {
        pushInstance.send('removeNodeType', {
            name: node.type,
            version: node.latestVersion,
        });
    });
    void __1.InternalHooksManager.getInstance().onCommunityPackageDeleteFinished({
        user_id: req.user.id,
        package_name: name,
        package_version: installedPackage.installedVersion,
        package_node_names: installedPackage.installedNodes.map((node) => node.name),
        package_author: installedPackage.authorName,
        package_author_email: installedPackage.authorEmail,
    });
}));
exports.nodesController.patch('/', __1.ResponseHelper.send(async (req) => {
    const { name } = req.body;
    if (!name) {
        throw new __1.ResponseHelper.ResponseError(PACKAGE_NAME_NOT_PROVIDED, undefined, 400);
    }
    const previouslyInstalledPackage = await (0, packageModel_1.findInstalledPackage)(name);
    if (!previouslyInstalledPackage) {
        throw new __1.ResponseHelper.ResponseError(PACKAGE_NOT_INSTALLED, undefined, 400);
    }
    try {
        const newInstalledPackage = await (0, __1.LoadNodesAndCredentials)().updateNpmModule((0, helpers_1.parseNpmPackageName)(name).packageName, previouslyInstalledPackage);
        const pushInstance = __1.Push.getInstance();
        previouslyInstalledPackage.installedNodes.forEach((node) => {
            pushInstance.send('removeNodeType', {
                name: node.type,
                version: node.latestVersion,
            });
        });
        newInstalledPackage.installedNodes.forEach((node) => {
            pushInstance.send('reloadNodeType', {
                name: node.name,
                version: node.latestVersion,
            });
        });
        void __1.InternalHooksManager.getInstance().onCommunityPackageUpdateFinished({
            user_id: req.user.id,
            package_name: name,
            package_version_current: previouslyInstalledPackage.installedVersion,
            package_version_new: newInstalledPackage.installedVersion,
            package_node_names: newInstalledPackage.installedNodes.map((node) => node.name),
            package_author: newInstalledPackage.authorName,
            package_author_email: newInstalledPackage.authorEmail,
        });
        return newInstalledPackage;
    }
    catch (error) {
        previouslyInstalledPackage.installedNodes.forEach((node) => {
            const pushInstance = __1.Push.getInstance();
            pushInstance.send('removeNodeType', {
                name: node.type,
                version: node.latestVersion,
            });
        });
        const message = [
            `Error removing package "${name}"`,
            error instanceof Error ? error.message : constants_1.UNKNOWN_FAILURE_REASON,
        ].join(':');
        throw new __1.ResponseHelper.ResponseError(message, undefined, 500);
    }
}));
//# sourceMappingURL=nodes.api.js.map