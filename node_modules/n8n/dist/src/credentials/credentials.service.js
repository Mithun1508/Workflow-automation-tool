"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialsService = void 0;
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const typeorm_1 = require("typeorm");
const __1 = require("..");
const constants_1 = require("../constants");
const CredentialsEntity_1 = require("../databases/entities/CredentialsEntity");
const SharedCredentials_1 = require("../databases/entities/SharedCredentials");
const GenericHelpers_1 = require("../GenericHelpers");
const Server_1 = require("../Server");
class CredentialsService {
    static async get(credential, options) {
        return __1.Db.collections.Credentials.findOne(credential, {
            relations: options === null || options === void 0 ? void 0 : options.relations,
        });
    }
    static async getAll(user, options) {
        const SELECT_FIELDS = [
            'id',
            'name',
            'type',
            'nodesAccess',
            'createdAt',
            'updatedAt',
        ];
        if (user.globalRole.name === 'owner') {
            return __1.Db.collections.Credentials.find({
                select: SELECT_FIELDS,
                relations: options === null || options === void 0 ? void 0 : options.relations,
            });
        }
        const userSharings = await __1.Db.collections.SharedCredentials.find({
            where: {
                user,
            },
        });
        return __1.Db.collections.Credentials.find({
            select: SELECT_FIELDS,
            relations: options === null || options === void 0 ? void 0 : options.relations,
            where: {
                id: (0, typeorm_1.In)(userSharings.map((x) => x.credentialId)),
            },
        });
    }
    static async getMany(filter) {
        return __1.Db.collections.Credentials.find(filter);
    }
    static async getSharing(user, credentialId, relations = ['credentials'], { allowGlobalOwner } = { allowGlobalOwner: true }) {
        const options = {
            where: {
                credentials: { id: credentialId },
            },
        };
        if (!allowGlobalOwner || user.globalRole.name !== 'owner') {
            options.where.user = { id: user.id };
        }
        if (relations === null || relations === void 0 ? void 0 : relations.length) {
            options.relations = relations;
        }
        return __1.Db.collections.SharedCredentials.findOne(options);
    }
    static createCredentialsFromCredentialsEntity(credential, encrypt = false) {
        const { id, name, type, nodesAccess, data } = credential;
        if (encrypt) {
            return new n8n_core_1.Credentials({ id: null, name }, type, nodesAccess);
        }
        return new n8n_core_1.Credentials({ id: id.toString(), name }, type, nodesAccess, data);
    }
    static async prepareCreateData(data) {
        const { id, ...rest } = data;
        const newCredentials = __1.Db.collections.Credentials.create(rest);
        await (0, GenericHelpers_1.validateEntity)(newCredentials);
        for (const nodeAccess of newCredentials.nodesAccess) {
            nodeAccess.date = new Date();
        }
        return newCredentials;
    }
    static async prepareUpdateData(data, decryptedData) {
        const updateData = __1.Db.collections.Credentials.create(data);
        await (0, GenericHelpers_1.validateEntity)(updateData);
        for (const nodeAccess of updateData.nodesAccess) {
            if (!nodeAccess.date) {
                nodeAccess.date = new Date();
            }
        }
        if (decryptedData.oauthTokenData) {
            updateData.data.oauthTokenData = decryptedData.oauthTokenData;
        }
        return updateData;
    }
    static createEncryptedData(encryptionKey, credentialsId, data) {
        const credentials = new n8n_core_1.Credentials({ id: credentialsId, name: data.name }, data.type, data.nodesAccess);
        credentials.setData(data.data, encryptionKey);
        const newCredentialData = credentials.getDataToSave();
        newCredentialData.updatedAt = new Date();
        return newCredentialData;
    }
    static async getEncryptionKey() {
        try {
            return await n8n_core_1.UserSettings.getEncryptionKey();
        }
        catch (error) {
            throw new __1.ResponseHelper.ResponseError(constants_1.RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY, undefined, 500);
        }
    }
    static async decrypt(encryptionKey, credential) {
        const coreCredential = (0, __1.createCredentialsFromCredentialsEntity)(credential);
        return coreCredential.getData(encryptionKey);
    }
    static async update(credentialId, newCredentialData) {
        await Server_1.externalHooks.run('credentials.update', [newCredentialData]);
        await __1.Db.collections.Credentials.update(credentialId, newCredentialData);
        return __1.Db.collections.Credentials.findOne(credentialId);
    }
    static async save(credential, encryptedData, user) {
        const newCredential = new CredentialsEntity_1.CredentialsEntity();
        Object.assign(newCredential, credential, encryptedData);
        await Server_1.externalHooks.run('credentials.create', [encryptedData]);
        const role = await __1.Db.collections.Role.findOneOrFail({
            name: 'owner',
            scope: 'credential',
        });
        const result = await __1.Db.transaction(async (transactionManager) => {
            const savedCredential = await transactionManager.save(newCredential);
            savedCredential.data = newCredential.data;
            const newSharedCredential = new SharedCredentials_1.SharedCredentials();
            Object.assign(newSharedCredential, {
                role,
                user,
                credentials: savedCredential,
            });
            await transactionManager.save(newSharedCredential);
            return savedCredential;
        });
        n8n_workflow_1.LoggerProxy.verbose('New credential created', {
            credentialId: newCredential.id,
            ownerId: user.id,
        });
        return result;
    }
    static async delete(credentials) {
        await Server_1.externalHooks.run('credentials.delete', [credentials.id]);
        await __1.Db.collections.Credentials.remove(credentials);
    }
    static async test(user, encryptionKey, credentials, nodeToTestWith) {
        const helper = new __1.CredentialsHelper(encryptionKey);
        return helper.testCredentials(user, credentials.type, credentials, nodeToTestWith);
    }
}
exports.CredentialsService = CredentialsService;
//# sourceMappingURL=credentials.service.js.map