"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.oauth2CredentialController = void 0;
const client_oauth2_1 = __importDefault(require("client-oauth2"));
const csrf_1 = __importDefault(require("csrf"));
const express_1 = __importDefault(require("express"));
const lodash_get_1 = __importDefault(require("lodash.get"));
const lodash_omit_1 = __importDefault(require("lodash.omit"));
const lodash_set_1 = __importDefault(require("lodash.set"));
const lodash_split_1 = __importDefault(require("lodash.split"));
const lodash_unset_1 = __importDefault(require("lodash.unset"));
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const path_1 = require("path");
const __1 = require("..");
const constants_1 = require("../constants");
const CredentialsHelper_1 = require("../CredentialsHelper");
const Logger_1 = require("../Logger");
const Server_1 = require("../Server");
const config_1 = __importDefault(require("../../config"));
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
exports.oauth2CredentialController = express_1.default.Router();
exports.oauth2CredentialController.use((req, res, next) => {
    try {
        n8n_workflow_1.LoggerProxy.getInstance();
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.init((0, Logger_1.getLogger)());
    }
    next();
});
const restEndpoint = config_1.default.getEnv('endpoints.rest');
exports.oauth2CredentialController.get('/auth', __1.ResponseHelper.send(async (req) => {
    const { id: credentialId } = req.query;
    if (!credentialId) {
        throw new __1.ResponseHelper.ResponseError('Required credential ID is missing', undefined, 400);
    }
    const credential = await (0, CredentialsHelper_1.getCredentialForUser)(credentialId, req.user);
    if (!credential) {
        n8n_workflow_1.LoggerProxy.error('Failed to authorize OAuth2 due to lack of permissions', {
            userId: req.user.id,
            credentialId,
        });
        throw new __1.ResponseHelper.ResponseError(constants_1.RESPONSE_ERROR_MESSAGES.NO_CREDENTIAL, undefined, 404);
    }
    let encryptionKey;
    try {
        encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
    }
    catch (error) {
        throw new __1.ResponseHelper.ResponseError(error.message, undefined, 500);
    }
    const mode = 'internal';
    const timezone = config_1.default.getEnv('generic.timezone');
    const credentialsHelper = new CredentialsHelper_1.CredentialsHelper(encryptionKey);
    const decryptedDataOriginal = await credentialsHelper.getDecrypted(credential, credential.type, mode, timezone, true);
    const oauthCredentials = credentialsHelper.applyDefaultsAndOverwrites(decryptedDataOriginal, credential.type, mode, timezone);
    const token = new csrf_1.default();
    const csrfSecret = token.secretSync();
    const state = {
        token: token.create(csrfSecret),
        cid: req.query.id,
    };
    const stateEncodedStr = Buffer.from(JSON.stringify(state)).toString('base64');
    const oAuthOptions = {
        clientId: (0, lodash_get_1.default)(oauthCredentials, 'clientId'),
        clientSecret: (0, lodash_get_1.default)(oauthCredentials, 'clientSecret', ''),
        accessTokenUri: (0, lodash_get_1.default)(oauthCredentials, 'accessTokenUrl', ''),
        authorizationUri: (0, lodash_get_1.default)(oauthCredentials, 'authUrl', ''),
        redirectUri: `${(0, UserManagementHelper_1.getInstanceBaseUrl)()}/${restEndpoint}/oauth2-credential/callback`,
        scopes: (0, lodash_split_1.default)((0, lodash_get_1.default)(oauthCredentials, 'scope', 'openid,'), ','),
        state: stateEncodedStr,
    };
    await Server_1.externalHooks.run('oauth2.authenticate', [oAuthOptions]);
    const oAuthObj = new client_oauth2_1.default(oAuthOptions);
    const credentials = new n8n_core_1.Credentials(credential, credential.type, credential.nodesAccess);
    decryptedDataOriginal.csrfSecret = csrfSecret;
    credentials.setData(decryptedDataOriginal, encryptionKey);
    const newCredentialsData = credentials.getDataToSave();
    newCredentialsData.updatedAt = new Date();
    await __1.Db.collections.Credentials.update(req.query.id, newCredentialsData);
    const authQueryParameters = (0, lodash_get_1.default)(oauthCredentials, 'authQueryParameters', '');
    let returnUri = oAuthObj.code.getUri();
    if ((0, lodash_get_1.default)(oauthCredentials, 'scope').includes(',')) {
        const data = returnUri.split('?')[1];
        const scope = (0, lodash_get_1.default)(oauthCredentials, 'scope');
        const percentEncoded = [data, `scope=${encodeURIComponent(scope)}`].join('&');
        returnUri = `${(0, lodash_get_1.default)(oauthCredentials, 'authUrl', '')}?${percentEncoded}`;
    }
    if (authQueryParameters) {
        returnUri += `&${authQueryParameters}`;
    }
    n8n_workflow_1.LoggerProxy.verbose('OAuth2 authentication successful for new credential', {
        userId: req.user.id,
        credentialId,
    });
    return returnUri;
}));
exports.oauth2CredentialController.get('/callback', async (req, res) => {
    var _a, _b, _c, _d;
    try {
        const { code, state: stateEncoded } = req.query;
        if (!code || !stateEncoded) {
            const errorResponse = new __1.ResponseHelper.ResponseError(`Insufficient parameters for OAuth2 callback. Received following query parameters: ${JSON.stringify(req.query)}`, undefined, 503);
            return __1.ResponseHelper.sendErrorResponse(res, errorResponse);
        }
        let state;
        try {
            state = JSON.parse(Buffer.from(stateEncoded, 'base64').toString());
        }
        catch (error) {
            const errorResponse = new __1.ResponseHelper.ResponseError('Invalid state format returned', undefined, 503);
            return __1.ResponseHelper.sendErrorResponse(res, errorResponse);
        }
        const credential = await (0, CredentialsHelper_1.getCredentialWithoutUser)(state.cid);
        if (!credential) {
            n8n_workflow_1.LoggerProxy.error('OAuth2 callback failed because of insufficient permissions', {
                userId: (_a = req.user) === null || _a === void 0 ? void 0 : _a.id,
                credentialId: state.cid,
            });
            const errorResponse = new __1.ResponseHelper.ResponseError(constants_1.RESPONSE_ERROR_MESSAGES.NO_CREDENTIAL, undefined, 404);
            return __1.ResponseHelper.sendErrorResponse(res, errorResponse);
        }
        let encryptionKey;
        try {
            encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
        }
        catch (error) {
            throw new __1.ResponseHelper.ResponseError(error.message, undefined, 500);
        }
        const mode = 'internal';
        const timezone = config_1.default.getEnv('generic.timezone');
        const credentialsHelper = new CredentialsHelper_1.CredentialsHelper(encryptionKey);
        const decryptedDataOriginal = await credentialsHelper.getDecrypted(credential, credential.type, mode, timezone, true);
        const oauthCredentials = credentialsHelper.applyDefaultsAndOverwrites(decryptedDataOriginal, credential.type, mode, timezone);
        const token = new csrf_1.default();
        if (decryptedDataOriginal.csrfSecret === undefined ||
            !token.verify(decryptedDataOriginal.csrfSecret, state.token)) {
            n8n_workflow_1.LoggerProxy.debug('OAuth2 callback state is invalid', {
                userId: (_b = req.user) === null || _b === void 0 ? void 0 : _b.id,
                credentialId: state.cid,
            });
            const errorResponse = new __1.ResponseHelper.ResponseError('The OAuth2 callback state is invalid!', undefined, 404);
            return __1.ResponseHelper.sendErrorResponse(res, errorResponse);
        }
        let options = {};
        const oAuth2Parameters = {
            clientId: (0, lodash_get_1.default)(oauthCredentials, 'clientId'),
            clientSecret: (0, lodash_get_1.default)(oauthCredentials, 'clientSecret', ''),
            accessTokenUri: (0, lodash_get_1.default)(oauthCredentials, 'accessTokenUrl', ''),
            authorizationUri: (0, lodash_get_1.default)(oauthCredentials, 'authUrl', ''),
            redirectUri: `${(0, UserManagementHelper_1.getInstanceBaseUrl)()}/${restEndpoint}/oauth2-credential/callback`,
            scopes: (0, lodash_split_1.default)((0, lodash_get_1.default)(oauthCredentials, 'scope', 'openid,'), ','),
        };
        if ((0, lodash_get_1.default)(oauthCredentials, 'authentication', 'header') === 'body') {
            options = {
                body: {
                    client_id: (0, lodash_get_1.default)(oauthCredentials, 'clientId'),
                    client_secret: (0, lodash_get_1.default)(oauthCredentials, 'clientSecret', ''),
                },
            };
            delete oAuth2Parameters.clientSecret;
        }
        await Server_1.externalHooks.run('oauth2.callback', [oAuth2Parameters]);
        const oAuthObj = new client_oauth2_1.default(oAuth2Parameters);
        const queryParameters = req.originalUrl.split('?').splice(1, 1).join('');
        const oauthToken = await oAuthObj.code.getToken(`${oAuth2Parameters.redirectUri}?${queryParameters}`, options);
        if (Object.keys(req.query).length > 2) {
            (0, lodash_set_1.default)(oauthToken.data, 'callbackQueryString', (0, lodash_omit_1.default)(req.query, 'state', 'code'));
        }
        if (oauthToken === undefined) {
            n8n_workflow_1.LoggerProxy.error('OAuth2 callback failed: unable to get access tokens', {
                userId: (_c = req.user) === null || _c === void 0 ? void 0 : _c.id,
                credentialId: state.cid,
            });
            const errorResponse = new __1.ResponseHelper.ResponseError('Unable to get access tokens!', undefined, 404);
            return __1.ResponseHelper.sendErrorResponse(res, errorResponse);
        }
        if (decryptedDataOriginal.oauthTokenData) {
            Object.assign(decryptedDataOriginal.oauthTokenData, oauthToken.data);
        }
        else {
            decryptedDataOriginal.oauthTokenData = oauthToken.data;
        }
        (0, lodash_unset_1.default)(decryptedDataOriginal, 'csrfSecret');
        const credentials = new n8n_core_1.Credentials(credential, credential.type, credential.nodesAccess);
        credentials.setData(decryptedDataOriginal, encryptionKey);
        const newCredentialsData = credentials.getDataToSave();
        newCredentialsData.updatedAt = new Date();
        await __1.Db.collections.Credentials.update(state.cid, newCredentialsData);
        n8n_workflow_1.LoggerProxy.verbose('OAuth2 callback successful for new credential', {
            userId: (_d = req.user) === null || _d === void 0 ? void 0 : _d.id,
            credentialId: state.cid,
        });
        return res.sendFile((0, path_1.resolve)(__dirname, '../../../templates/oauth-callback.html'));
    }
    catch (error) {
        return __1.ResponseHelper.sendErrorResponse(res, error);
    }
});
//# sourceMappingURL=oauth2Credential.api.js.map