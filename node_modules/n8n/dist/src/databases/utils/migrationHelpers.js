"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.escapeQuery = exports.getTablePrefix = exports.runInBatches = exports.batchQuery = exports.logMigrationEnd = exports.logMigrationStart = exports.loadSurveyFromDisk = void 0;
const fs_1 = require("fs");
const n8n_core_1 = require("n8n-core");
const config_1 = __importDefault(require("../../../config"));
const Logger_1 = require("../../Logger");
const PERSONALIZATION_SURVEY_FILENAME = 'personalizationSurvey.json';
function loadSurveyFromDisk() {
    const userSettingsPath = n8n_core_1.UserSettings.getUserN8nFolderPath();
    try {
        const filename = `${userSettingsPath}/${PERSONALIZATION_SURVEY_FILENAME}`;
        const surveyFile = (0, fs_1.readFileSync)(filename, 'utf-8');
        (0, fs_1.rmSync)(filename);
        const personalizationSurvey = JSON.parse(surveyFile);
        const kvPairs = Object.entries(personalizationSurvey);
        if (!kvPairs.length) {
            throw new Error('personalizationSurvey is empty');
        }
        else {
            const emptyKeys = kvPairs.reduce((acc, [_key, value]) => {
                if (!value || (Array.isArray(value) && !value.length)) {
                    return acc + 1;
                }
                return acc;
            }, 0);
            if (emptyKeys === kvPairs.length) {
                throw new Error('incomplete personalizationSurvey');
            }
        }
        return surveyFile;
    }
    catch (error) {
        return null;
    }
}
exports.loadSurveyFromDisk = loadSurveyFromDisk;
let logFinishTimeout;
function logMigrationStart(migrationName, disableLogging = process.env.NODE_ENV === 'test') {
    if (disableLogging)
        return;
    if (!logFinishTimeout) {
        (0, Logger_1.getLogger)().warn('Migrations in progress, please do NOT stop the process.');
    }
    (0, Logger_1.getLogger)().debug(`Starting migration ${migrationName}`);
    clearTimeout(logFinishTimeout);
}
exports.logMigrationStart = logMigrationStart;
function logMigrationEnd(migrationName, disableLogging = process.env.NODE_ENV === 'test') {
    if (disableLogging)
        return;
    (0, Logger_1.getLogger)().debug(`Finished migration ${migrationName}`);
    logFinishTimeout = setTimeout(() => {
        (0, Logger_1.getLogger)().warn('Migrations finished.');
    }, 100);
}
exports.logMigrationEnd = logMigrationEnd;
function batchQuery(query, limit, offset = 0) {
    return `
			${query}
			LIMIT ${limit}
			OFFSET ${offset}
		`;
}
exports.batchQuery = batchQuery;
async function runInBatches(queryRunner, query, operation, limit = 100) {
    let offset = 0;
    let batchedQuery;
    let batchedQueryResults;
    if (query.trim().endsWith(';'))
        query = query.trim().slice(0, -1);
    do {
        batchedQuery = batchQuery(query, limit, offset);
        batchedQueryResults = (await queryRunner.query(batchedQuery));
        await operation([...batchedQueryResults]);
        offset += limit;
    } while (batchedQueryResults.length === limit);
}
exports.runInBatches = runInBatches;
const getTablePrefix = () => {
    const tablePrefix = config_1.default.getEnv('database.tablePrefix');
    if (config_1.default.getEnv('database.type') === 'postgresdb') {
        const schema = config_1.default.getEnv('database.postgresdb.schema');
        return [schema, tablePrefix].join('.');
    }
    return tablePrefix;
};
exports.getTablePrefix = getTablePrefix;
const escapeQuery = (queryRunner, query, params) => queryRunner.connection.driver.escapeQueryWithParameters(query, {
    pinData: params.pinData,
    id: params.id,
}, {});
exports.escapeQuery = escapeQuery;
//# sourceMappingURL=migrationHelpers.js.map