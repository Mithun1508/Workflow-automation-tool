"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Telemetry = void 0;
const rudder_sdk_node_1 = __importDefault(require("@rudderstack/rudder-sdk-node"));
const posthog_node_1 = __importDefault(require("posthog-node"));
const n8n_workflow_1 = require("n8n-workflow");
const config_1 = __importDefault(require("../../config"));
const Logger_1 = require("../Logger");
class Telemetry {
    constructor(instanceId, versionCli) {
        this.executionCountsBuffer = {};
        this.instanceId = instanceId;
        this.versionCli = versionCli;
        const enabled = config_1.default.getEnv('diagnostics.enabled');
        const logLevel = config_1.default.getEnv('logs.level');
        if (enabled) {
            const conf = config_1.default.getEnv('diagnostics.config.backend');
            const [key, url] = conf.split(';');
            if (!key || !url) {
                const logger = (0, Logger_1.getLogger)();
                n8n_workflow_1.LoggerProxy.init(logger);
                logger.warn('Diagnostics backend config is invalid');
                return;
            }
            this.rudderStack = this.initRudderStack(key, url, logLevel);
            this.postHog = this.initPostHog();
            this.startPulse();
        }
    }
    initRudderStack(key, url, logLevel) {
        return new rudder_sdk_node_1.default(key, url, { logLevel });
    }
    initPostHog() {
        return new posthog_node_1.default(config_1.default.getEnv('diagnostics.config.posthog.apiKey'));
    }
    startPulse() {
        this.pulseIntervalReference = setInterval(async () => {
            void this.pulse();
        }, 6 * 60 * 60 * 1000);
    }
    async pulse() {
        if (!this.rudderStack) {
            return Promise.resolve();
        }
        const allPromises = Object.keys(this.executionCountsBuffer).map(async (workflowId) => {
            const promise = this.track('Workflow execution count', {
                event_version: '2',
                workflow_id: workflowId,
                ...this.executionCountsBuffer[workflowId],
            });
            return promise;
        });
        this.executionCountsBuffer = {};
        allPromises.push(this.track('pulse'));
        return Promise.all(allPromises);
    }
    async trackWorkflowExecution(properties) {
        var _a, _b;
        if (this.rudderStack) {
            const execTime = new Date();
            const workflowId = properties.workflow_id;
            this.executionCountsBuffer[workflowId] = (_a = this.executionCountsBuffer[workflowId]) !== null && _a !== void 0 ? _a : {};
            const key = `${properties.is_manual ? 'manual' : 'prod'}_${properties.success ? 'success' : 'error'}`;
            if (!this.executionCountsBuffer[workflowId][key]) {
                this.executionCountsBuffer[workflowId][key] = {
                    count: 1,
                    first: execTime,
                };
            }
            else {
                this.executionCountsBuffer[workflowId][key].count++;
            }
            if (!properties.success && ((_b = properties.error_node_type) === null || _b === void 0 ? void 0 : _b.startsWith('n8n-nodes-base'))) {
                void this.track('Workflow execution errored', properties);
            }
        }
    }
    async trackN8nStop() {
        clearInterval(this.pulseIntervalReference);
        void this.track('User instance stopped');
        return new Promise((resolve) => {
            if (this.postHog) {
                this.postHog.shutdown();
            }
            if (this.rudderStack) {
                this.rudderStack.flush(resolve);
            }
            else {
                resolve();
            }
        });
    }
    async identify(traits) {
        return new Promise((resolve) => {
            if (this.rudderStack) {
                this.rudderStack.identify({
                    userId: this.instanceId,
                    anonymousId: '000000000000',
                    traits: {
                        ...traits,
                        instanceId: this.instanceId,
                    },
                }, resolve);
            }
            else {
                resolve();
            }
        });
    }
    async track(eventName, properties = {}, { withPostHog } = { withPostHog: false }) {
        return new Promise((resolve) => {
            if (this.rudderStack) {
                const { user_id } = properties;
                const updatedProperties = {
                    ...properties,
                    instance_id: this.instanceId,
                    version_cli: this.versionCli,
                };
                const payload = {
                    userId: `${this.instanceId}${user_id ? `#${user_id}` : ''}`,
                    anonymousId: '000000000000',
                    event: eventName,
                    properties: updatedProperties,
                };
                if (withPostHog && this.postHog) {
                    return Promise.all([
                        this.postHog.capture({
                            distinctId: payload.userId,
                            ...payload,
                        }),
                        this.rudderStack.track(payload),
                    ]).then(() => resolve());
                }
                return this.rudderStack.track(payload, resolve);
            }
            return resolve();
        });
    }
    async isFeatureFlagEnabled(featureFlagName, { user_id: userId } = {}) {
        if (!this.postHog)
            return Promise.resolve(false);
        const fullId = [this.instanceId, userId].join('#');
        return this.postHog.isFeatureEnabled(featureFlagName, fullId);
    }
    getCountsBuffer() {
        return this.executionCountsBuffer;
    }
}
exports.Telemetry = Telemetry;
//# sourceMappingURL=index.js.map