"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EEWorkflowController = void 0;
const express_1 = __importDefault(require("express"));
const __1 = require("..");
const config_1 = __importDefault(require("../../config"));
const WorkflowEntity_1 = require("../databases/entities/WorkflowEntity");
const GenericHelpers_1 = require("../GenericHelpers");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const workflows_services_ee_1 = require("./workflows.services.ee");
const Server_1 = require("../Server");
const SharedWorkflow_1 = require("../databases/entities/SharedWorkflow");
const n8n_workflow_1 = require("n8n-workflow");
const TagHelpers = __importStar(require("../TagHelpers"));
const credentials_service_ee_1 = require("../credentials/credentials.service.ee");
exports.EEWorkflowController = express_1.default.Router();
exports.EEWorkflowController.use((req, res, next) => {
    if (!(0, UserManagementHelper_1.isSharingEnabled)() || !config_1.default.getEnv('enterprise.workflowSharingEnabled')) {
        next('router');
        return;
    }
    next();
});
exports.EEWorkflowController.put('/:workflowId/share', async (req, res) => {
    const { workflowId } = req.params;
    const { shareWithIds } = req.body;
    if (!Array.isArray(shareWithIds) || !shareWithIds.every((userId) => typeof userId === 'string')) {
        return res.status(400).send('Bad Request');
    }
    const { ownsWorkflow, workflow } = await workflows_services_ee_1.EEWorkflowsService.isOwned(req.user, workflowId);
    if (!ownsWorkflow || !workflow) {
        return res.status(403).send();
    }
    let newShareeIds = [];
    await __1.Db.transaction(async (trx) => {
        await workflows_services_ee_1.EEWorkflowsService.pruneSharings(trx, workflowId, [req.user.id, ...shareWithIds]);
        const sharings = await workflows_services_ee_1.EEWorkflowsService.getSharings(trx, workflowId);
        newShareeIds = (0, UserManagementHelper_1.rightDiff)([sharings, (sharing) => sharing.userId], [shareWithIds, (shareeId) => shareeId]);
        if (newShareeIds.length) {
            await workflows_services_ee_1.EEWorkflowsService.share(trx, workflow, newShareeIds);
        }
    });
    return res.status(200).send();
});
exports.EEWorkflowController.get('/:id(\\d+)', __1.ResponseHelper.send(async (req) => {
    var _a;
    const { id: workflowId } = req.params;
    const workflow = await workflows_services_ee_1.EEWorkflowsService.get({ id: parseInt(workflowId, 10) }, { relations: ['shared', 'shared.user', 'shared.role'] });
    if (!workflow) {
        throw new __1.ResponseHelper.ResponseError(`Workflow with ID "${workflowId}" could not be found.`, undefined, 404);
    }
    const userSharing = (_a = workflow.shared) === null || _a === void 0 ? void 0 : _a.find((shared) => shared.user.id === req.user.id);
    if (!userSharing && req.user.globalRole.name !== 'owner') {
        throw new __1.ResponseHelper.ResponseError(`Forbidden.`, undefined, 403);
    }
    return workflows_services_ee_1.EEWorkflowsService.addCredentialsToWorkflow(workflows_services_ee_1.EEWorkflowsService.addOwnerAndSharings(workflow), req.user);
}));
exports.EEWorkflowController.post('/', __1.ResponseHelper.send(async (req) => {
    delete req.body.id;
    const newWorkflow = new WorkflowEntity_1.WorkflowEntity();
    Object.assign(newWorkflow, req.body);
    await (0, GenericHelpers_1.validateEntity)(newWorkflow);
    await Server_1.externalHooks.run('workflow.create', [newWorkflow]);
    const { tags: tagIds } = req.body;
    if ((tagIds === null || tagIds === void 0 ? void 0 : tagIds.length) && !config_1.default.getEnv('workflowTagsDisabled')) {
        newWorkflow.tags = await __1.Db.collections.Tag.findByIds(tagIds, {
            select: ['id', 'name'],
        });
    }
    await __1.WorkflowHelpers.replaceInvalidCredentials(newWorkflow);
    __1.WorkflowHelpers.addNodeIds(newWorkflow);
    const allCredentials = await credentials_service_ee_1.EECredentialsService.getAll(req.user);
    try {
        workflows_services_ee_1.EEWorkflowsService.validateCredentialPermissionsToUser(newWorkflow, allCredentials);
    }
    catch (error) {
        throw new __1.ResponseHelper.ResponseError('The workflow contains credentials that you do not have access to', undefined, 400);
    }
    let savedWorkflow;
    await __1.Db.transaction(async (transactionManager) => {
        savedWorkflow = await transactionManager.save(newWorkflow);
        const role = await __1.Db.collections.Role.findOneOrFail({
            name: 'owner',
            scope: 'workflow',
        });
        const newSharedWorkflow = new SharedWorkflow_1.SharedWorkflow();
        Object.assign(newSharedWorkflow, {
            role,
            user: req.user,
            workflow: savedWorkflow,
        });
        await transactionManager.save(newSharedWorkflow);
    });
    if (!savedWorkflow) {
        n8n_workflow_1.LoggerProxy.error('Failed to create workflow', { userId: req.user.id });
        throw new __1.ResponseHelper.ResponseError('Failed to save workflow');
    }
    if (tagIds && !config_1.default.getEnv('workflowTagsDisabled') && savedWorkflow.tags) {
        savedWorkflow.tags = TagHelpers.sortByRequestOrder(savedWorkflow.tags, {
            requestOrder: tagIds,
        });
    }
    await Server_1.externalHooks.run('workflow.afterCreate', [savedWorkflow]);
    void __1.InternalHooksManager.getInstance().onWorkflowCreated(req.user.id, newWorkflow, false);
    const { id, ...rest } = savedWorkflow;
    return {
        id: id.toString(),
        ...rest,
    };
}));
exports.EEWorkflowController.patch('/:id(\\d+)', __1.ResponseHelper.send(async (req) => {
    const { id: workflowId } = req.params;
    const forceSave = req.query.forceSave === 'true';
    const updateData = new WorkflowEntity_1.WorkflowEntity();
    const { tags, ...rest } = req.body;
    Object.assign(updateData, rest);
    const updatedWorkflow = await workflows_services_ee_1.EEWorkflowsService.updateWorkflow(req.user, updateData, workflowId, tags, forceSave);
    const { id, ...remainder } = updatedWorkflow;
    return {
        id: id.toString(),
        ...remainder,
    };
}));
//# sourceMappingURL=workflows.controller.ee.js.map