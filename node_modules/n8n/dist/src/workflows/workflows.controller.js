"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.workflowsController = void 0;
const express_1 = __importDefault(require("express"));
const n8n_workflow_1 = require("n8n-workflow");
const axios_1 = __importDefault(require("axios"));
const typeorm_1 = require("typeorm");
const __1 = require("..");
const config_1 = __importDefault(require("../../config"));
const TagHelpers = __importStar(require("../TagHelpers"));
const SharedWorkflow_1 = require("../databases/entities/SharedWorkflow");
const WorkflowEntity_1 = require("../databases/entities/WorkflowEntity");
const GenericHelpers_1 = require("../GenericHelpers");
const InternalHooksManager_1 = require("../InternalHooksManager");
const Server_1 = require("../Server");
const Logger_1 = require("../Logger");
const WorkflowHelpers_1 = require("../WorkflowHelpers");
const workflows_controller_ee_1 = require("./workflows.controller.ee");
const workflows_services_1 = require("./workflows.services");
const jsonschema_1 = require("jsonschema");
const activeWorkflowRunner = __1.ActiveWorkflowRunner.getInstance();
exports.workflowsController = express_1.default.Router();
const schemaGetWorkflowsQueryFilter = {
    $id: '/IGetWorkflowsQueryFilter',
    type: 'object',
    properties: {
        id: { anyOf: [{ type: 'integer' }, { type: 'string' }] },
        name: { type: 'string' },
        active: { type: 'boolean' },
    },
};
const allowedWorkflowsQueryFilterFields = Object.keys(schemaGetWorkflowsQueryFilter.properties);
exports.workflowsController.use((req, res, next) => {
    try {
        n8n_workflow_1.LoggerProxy.getInstance();
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.init((0, Logger_1.getLogger)());
    }
    next();
});
exports.workflowsController.use('/', workflows_controller_ee_1.EEWorkflowController);
const isTrigger = (nodeType) => ['trigger', 'webhook'].some((suffix) => nodeType.toLowerCase().includes(suffix));
function findFirstPinnedTrigger(workflow, pinData) {
    if (!pinData)
        return;
    return workflow.nodes.find((node) => !node.disabled && isTrigger(node.type) && pinData[node.name]);
}
exports.workflowsController.post('/', __1.ResponseHelper.send(async (req) => {
    delete req.body.id;
    const newWorkflow = new WorkflowEntity_1.WorkflowEntity();
    Object.assign(newWorkflow, req.body);
    await (0, GenericHelpers_1.validateEntity)(newWorkflow);
    await Server_1.externalHooks.run('workflow.create', [newWorkflow]);
    const { tags: tagIds } = req.body;
    if ((tagIds === null || tagIds === void 0 ? void 0 : tagIds.length) && !config_1.default.getEnv('workflowTagsDisabled')) {
        newWorkflow.tags = await __1.Db.collections.Tag.findByIds(tagIds, {
            select: ['id', 'name'],
        });
    }
    await __1.WorkflowHelpers.replaceInvalidCredentials(newWorkflow);
    __1.WorkflowHelpers.addNodeIds(newWorkflow);
    let savedWorkflow;
    await __1.Db.transaction(async (transactionManager) => {
        savedWorkflow = await transactionManager.save(newWorkflow);
        const role = await __1.Db.collections.Role.findOneOrFail({
            name: 'owner',
            scope: 'workflow',
        });
        const newSharedWorkflow = new SharedWorkflow_1.SharedWorkflow();
        Object.assign(newSharedWorkflow, {
            role,
            user: req.user,
            workflow: savedWorkflow,
        });
        await transactionManager.save(newSharedWorkflow);
    });
    if (!savedWorkflow) {
        n8n_workflow_1.LoggerProxy.error('Failed to create workflow', { userId: req.user.id });
        throw new __1.ResponseHelper.ResponseError('Failed to save workflow');
    }
    if (tagIds && !config_1.default.getEnv('workflowTagsDisabled') && savedWorkflow.tags) {
        savedWorkflow.tags = TagHelpers.sortByRequestOrder(savedWorkflow.tags, {
            requestOrder: tagIds,
        });
    }
    await Server_1.externalHooks.run('workflow.afterCreate', [savedWorkflow]);
    void InternalHooksManager_1.InternalHooksManager.getInstance().onWorkflowCreated(req.user.id, newWorkflow, false);
    const { id, ...rest } = savedWorkflow;
    return {
        id: id.toString(),
        ...rest,
    };
}));
exports.workflowsController.get(`/`, __1.ResponseHelper.send(async (req) => {
    const sharedWorkflowIds = await (0, WorkflowHelpers_1.getSharedWorkflowIds)(req.user);
    if (sharedWorkflowIds.length === 0) {
        return [];
    }
    let filter = undefined;
    if (req.query.filter) {
        try {
            const filterJson = (0, n8n_workflow_1.jsonParse)(req.query.filter);
            if (filterJson) {
                Object.keys(filterJson).map((key) => {
                    if (!allowedWorkflowsQueryFilterFields.includes(key))
                        delete filterJson[key];
                });
                if ((0, jsonschema_1.validate)(filterJson, schemaGetWorkflowsQueryFilter).valid) {
                    filter = filterJson;
                }
            }
        }
        catch (error) {
            n8n_workflow_1.LoggerProxy.error('Failed to parse filter', {
                userId: req.user.id,
                filter: req.query.filter,
            });
            throw new __1.ResponseHelper.ResponseError(`Parameter "filter" contained invalid JSON string.`, 500, 500);
        }
    }
    if ((filter === null || filter === void 0 ? void 0 : filter.id) !== undefined) {
        const workflowId = parseInt(filter.id.toString());
        if (workflowId && !sharedWorkflowIds.includes(workflowId)) {
            n8n_workflow_1.LoggerProxy.verbose(`User ${req.user.id} attempted to query non-shared workflow ${workflowId}`);
            return [];
        }
    }
    const query = {
        select: ['id', 'name', 'active', 'createdAt', 'updatedAt'],
        relations: ['tags'],
    };
    if (config_1.default.getEnv('workflowTagsDisabled')) {
        delete query.relations;
    }
    const workflows = await __1.Db.collections.Workflow.find(Object.assign(query, {
        where: {
            id: (0, typeorm_1.In)(sharedWorkflowIds),
            ...filter,
        },
    }));
    return workflows.map((workflow) => {
        const { id, ...rest } = workflow;
        return {
            id: id.toString(),
            ...rest,
        };
    });
}));
exports.workflowsController.get(`/new`, __1.ResponseHelper.send(async (req) => {
    var _a;
    const requestedName = req.query.name && req.query.name !== ''
        ? req.query.name
        : config_1.default.getEnv('workflows.defaultName');
    const name = await __1.GenericHelpers.generateUniqueName(requestedName, 'workflow');
    const onboardingFlowEnabled = !config_1.default.getEnv('workflows.onboardingFlowDisabled') &&
        !((_a = req.user.settings) === null || _a === void 0 ? void 0 : _a.isOnboarded) &&
        (await (0, WorkflowHelpers_1.isBelowOnboardingThreshold)(req.user));
    return { name, onboardingFlowEnabled };
}));
exports.workflowsController.get(`/from-url`, __1.ResponseHelper.send(async (req) => {
    if (req.query.url === undefined) {
        throw new __1.ResponseHelper.ResponseError(`The parameter "url" is missing!`, undefined, 400);
    }
    if (!/^http[s]?:\/\/.*\.json$/i.exec(req.query.url)) {
        throw new __1.ResponseHelper.ResponseError(`The parameter "url" is not valid! It does not seem to be a URL pointing to a n8n workflow JSON file.`, undefined, 400);
    }
    let workflowData;
    try {
        const { data } = await axios_1.default.get(req.query.url);
        workflowData = data;
    }
    catch (error) {
        throw new __1.ResponseHelper.ResponseError(`The URL does not point to valid JSON file!`, undefined, 400);
    }
    if (workflowData === undefined ||
        workflowData.nodes === undefined ||
        !Array.isArray(workflowData.nodes) ||
        workflowData.connections === undefined ||
        typeof workflowData.connections !== 'object' ||
        Array.isArray(workflowData.connections)) {
        throw new __1.ResponseHelper.ResponseError(`The data in the file does not seem to be a n8n workflow JSON file!`, undefined, 400);
    }
    return workflowData;
}));
exports.workflowsController.get('/:id(\\d+)', __1.ResponseHelper.send(async (req) => {
    const { id: workflowId } = req.params;
    let relations = ['workflow', 'workflow.tags'];
    if (config_1.default.getEnv('workflowTagsDisabled')) {
        relations = relations.filter((relation) => relation !== 'workflow.tags');
    }
    const shared = await __1.Db.collections.SharedWorkflow.findOne({
        relations,
        where: (0, __1.whereClause)({
            user: req.user,
            entityType: 'workflow',
            entityId: workflowId,
        }),
    });
    if (!shared) {
        n8n_workflow_1.LoggerProxy.info('User attempted to access a workflow without permissions', {
            workflowId,
            userId: req.user.id,
        });
        throw new __1.ResponseHelper.ResponseError(`Workflow with ID "${workflowId}" could not be found.`, undefined, 404);
    }
    const { workflow: { id, ...rest }, } = shared;
    return {
        id: id.toString(),
        ...rest,
    };
}));
exports.workflowsController.patch(`/:id`, __1.ResponseHelper.send(async (req) => {
    const { id: workflowId } = req.params;
    const updateData = new WorkflowEntity_1.WorkflowEntity();
    const { tags, ...rest } = req.body;
    Object.assign(updateData, rest);
    const updatedWorkflow = await workflows_services_1.WorkflowsService.updateWorkflow(req.user, updateData, workflowId, tags);
    const { id, ...remainder } = updatedWorkflow;
    return {
        id: id.toString(),
        ...remainder,
    };
}));
exports.workflowsController.delete(`/:id`, __1.ResponseHelper.send(async (req) => {
    const { id: workflowId } = req.params;
    await Server_1.externalHooks.run('workflow.delete', [workflowId]);
    const shared = await __1.Db.collections.SharedWorkflow.findOne({
        relations: ['workflow'],
        where: (0, __1.whereClause)({
            user: req.user,
            entityType: 'workflow',
            entityId: workflowId,
        }),
    });
    if (!shared) {
        n8n_workflow_1.LoggerProxy.info('User attempted to delete a workflow without permissions', {
            workflowId,
            userId: req.user.id,
        });
        throw new __1.ResponseHelper.ResponseError(`Workflow with ID "${workflowId}" could not be found to be deleted.`, undefined, 400);
    }
    if (shared.workflow.active) {
        await activeWorkflowRunner.remove(workflowId);
    }
    await __1.Db.collections.Workflow.delete(workflowId);
    void InternalHooksManager_1.InternalHooksManager.getInstance().onWorkflowDeleted(req.user.id, workflowId, false);
    await Server_1.externalHooks.run('workflow.afterDelete', [workflowId]);
    return true;
}));
exports.workflowsController.post(`/run`, __1.ResponseHelper.send(async (req) => {
    var _a;
    const { workflowData } = req.body;
    const { runData } = req.body;
    const { pinData } = req.body;
    const { startNodes } = req.body;
    const { destinationNode } = req.body;
    const executionMode = 'manual';
    const activationMode = 'manual';
    const sessionId = __1.GenericHelpers.getSessionId(req);
    const pinnedTrigger = findFirstPinnedTrigger(workflowData, pinData);
    if (pinnedTrigger === undefined &&
        (runData === undefined ||
            startNodes === undefined ||
            startNodes.length === 0 ||
            destinationNode === undefined)) {
        const additionalData = await __1.WorkflowExecuteAdditionalData.getBase(req.user.id);
        const nodeTypes = (0, __1.NodeTypes)();
        const workflowInstance = new n8n_workflow_1.Workflow({
            id: (_a = workflowData.id) === null || _a === void 0 ? void 0 : _a.toString(),
            name: workflowData.name,
            nodes: workflowData.nodes,
            connections: workflowData.connections,
            active: false,
            nodeTypes,
            staticData: undefined,
            settings: workflowData.settings,
        });
        const needsWebhook = await __1.TestWebhooks.getInstance().needsWebhookData(workflowData, workflowInstance, additionalData, executionMode, activationMode, sessionId, destinationNode);
        if (needsWebhook) {
            return {
                waitingForWebhook: true,
            };
        }
    }
    workflowData.active = false;
    const data = {
        destinationNode,
        executionMode,
        runData,
        pinData,
        sessionId,
        startNodes,
        workflowData,
        userId: req.user.id,
    };
    const hasRunData = (node) => runData !== undefined && !!runData[node.name];
    if (pinnedTrigger && !hasRunData(pinnedTrigger)) {
        data.startNodes = [pinnedTrigger.name];
    }
    const workflowRunner = new __1.WorkflowRunner();
    const executionId = await workflowRunner.run(data);
    return {
        executionId,
    };
}));
//# sourceMappingURL=workflows.controller.js.map