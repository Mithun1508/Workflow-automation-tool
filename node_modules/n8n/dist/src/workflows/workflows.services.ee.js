"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EEWorkflowsService = void 0;
const typeorm_1 = require("typeorm");
const __1 = require("..");
const SharedWorkflow_1 = require("../databases/entities/SharedWorkflow");
const WorkflowEntity_1 = require("../databases/entities/WorkflowEntity");
const role_service_1 = require("../role/role.service");
const user_service_1 = require("../user/user.service");
const workflows_services_1 = require("./workflows.services");
const credentials_service_ee_1 = require("../credentials/credentials.service.ee");
class EEWorkflowsService extends workflows_services_1.WorkflowsService {
    static async isOwned(user, workflowId) {
        const sharing = await this.getSharing(user, workflowId, ['workflow', 'role'], {
            allowGlobalOwner: false,
        });
        if (!sharing || sharing.role.name !== 'owner')
            return { ownsWorkflow: false };
        const { workflow } = sharing;
        return { ownsWorkflow: true, workflow };
    }
    static async getSharings(transaction, workflowId) {
        var _a;
        const workflow = await transaction.findOne(WorkflowEntity_1.WorkflowEntity, workflowId, {
            relations: ['shared'],
        });
        return (_a = workflow === null || workflow === void 0 ? void 0 : workflow.shared) !== null && _a !== void 0 ? _a : [];
    }
    static async pruneSharings(transaction, workflowId, userIds) {
        return transaction.delete(SharedWorkflow_1.SharedWorkflow, {
            workflow: { id: workflowId },
            user: { id: (0, typeorm_1.Not)((0, typeorm_1.In)(userIds)) },
        });
    }
    static async share(transaction, workflow, shareWithIds) {
        const [users, role] = await Promise.all([
            user_service_1.UserService.getByIds(transaction, shareWithIds),
            role_service_1.RoleService.trxGet(transaction, { scope: 'workflow', name: 'editor' }),
        ]);
        const newSharedWorkflows = users.reduce((acc, user) => {
            if (user.isPending) {
                return acc;
            }
            acc.push(__1.Db.collections.SharedWorkflow.create({
                workflow,
                user,
                role,
            }));
            return acc;
        }, []);
        return transaction.save(newSharedWorkflows);
    }
    static addOwnerAndSharings(workflow) {
        var _a;
        workflow.ownedBy = null;
        workflow.sharedWith = [];
        workflow.usedCredentials = [];
        (_a = workflow.shared) === null || _a === void 0 ? void 0 : _a.forEach(({ user, role }) => {
            var _a;
            const { id, email, firstName, lastName } = user;
            if (role.name === 'owner') {
                workflow.ownedBy = { id, email, firstName, lastName };
                return;
            }
            (_a = workflow.sharedWith) === null || _a === void 0 ? void 0 : _a.push({ id, email, firstName, lastName });
        });
        delete workflow.shared;
        return workflow;
    }
    static async addCredentialsToWorkflow(workflow, currentUser) {
        workflow.usedCredentials = [];
        const userCredentials = await credentials_service_ee_1.EECredentialsService.getAll(currentUser);
        const credentialIdsUsedByWorkflow = new Set();
        workflow.nodes.forEach((node) => {
            if (!node.credentials) {
                return;
            }
            Object.keys(node.credentials).forEach((credentialType) => {
                var _a;
                const credential = (_a = node.credentials) === null || _a === void 0 ? void 0 : _a[credentialType];
                if (!(credential === null || credential === void 0 ? void 0 : credential.id)) {
                    return;
                }
                const credentialId = parseInt(credential.id, 10);
                credentialIdsUsedByWorkflow.add(credentialId);
            });
        });
        const workflowCredentials = await credentials_service_ee_1.EECredentialsService.getMany({
            where: {
                id: (0, typeorm_1.In)(Array.from(credentialIdsUsedByWorkflow)),
            },
        });
        const userCredentialIds = userCredentials.map((credential) => credential.id.toString());
        workflowCredentials.forEach((credential) => {
            var _a;
            const credentialId = credential.id.toString();
            (_a = workflow.usedCredentials) === null || _a === void 0 ? void 0 : _a.push({
                id: credential.id.toString(),
                name: credential.name,
                currentUserHasAccess: userCredentialIds.includes(credentialId),
            });
        });
        return workflow;
    }
    static validateCredentialPermissionsToUser(workflow, allowedCredentials) {
        workflow.nodes.forEach((node) => {
            if (!node.credentials) {
                return;
            }
            Object.keys(node.credentials).forEach((credentialType) => {
                var _a, _b;
                const credentialId = parseInt((_b = (_a = node.credentials) === null || _a === void 0 ? void 0 : _a[credentialType].id) !== null && _b !== void 0 ? _b : '', 10);
                const matchedCredential = allowedCredentials.find((credential) => credential.id === credentialId);
                if (!matchedCredential) {
                    throw new Error('The workflow contains credentials that you do not have access to');
                }
            });
        });
    }
    static async updateWorkflow(user, workflow, workflowId, tags, forceSave) {
        const previousVersion = await EEWorkflowsService.get({ id: parseInt(workflowId, 10) });
        if (!previousVersion) {
            throw new __1.ResponseHelper.ResponseError('Workflow not found', undefined, 404);
        }
        const allCredentials = await credentials_service_ee_1.EECredentialsService.getAll(user);
        try {
            workflow = __1.WorkflowHelpers.validateWorkflowCredentialUsage(workflow, previousVersion, allCredentials);
        }
        catch (error) {
            throw new __1.ResponseHelper.ResponseError('Invalid workflow credentials - make sure you have access to all credentials and try again.', undefined, 400);
        }
        return super.updateWorkflow(user, workflow, workflowId, tags, forceSave);
    }
}
exports.EEWorkflowsService = EEWorkflowsService;
//# sourceMappingURL=workflows.services.ee.js.map