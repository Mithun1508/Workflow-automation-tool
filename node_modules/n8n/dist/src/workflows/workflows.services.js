"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowsService = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const __1 = require("..");
const config_1 = __importDefault(require("../../config"));
const GenericHelpers_1 = require("../GenericHelpers");
const Server_1 = require("../Server");
const TagHelpers = __importStar(require("../TagHelpers"));
class WorkflowsService {
    static async getSharing(user, workflowId, relations = ['workflow'], { allowGlobalOwner } = { allowGlobalOwner: true }) {
        const options = {
            where: {
                workflow: { id: workflowId },
            },
        };
        if (!allowGlobalOwner || user.globalRole.name !== 'owner') {
            options.where.user = { id: user.id };
        }
        if (relations === null || relations === void 0 ? void 0 : relations.length) {
            options.relations = relations;
        }
        return __1.Db.collections.SharedWorkflow.findOne(options);
    }
    static async get(workflow, options) {
        return __1.Db.collections.Workflow.findOne(workflow, options);
    }
    static async updateWorkflow(user, workflow, workflowId, tags, forceSave) {
        var _a;
        const shared = await __1.Db.collections.SharedWorkflow.findOne({
            relations: ['workflow'],
            where: (0, __1.whereClause)({
                user,
                entityType: 'workflow',
                entityId: workflowId,
            }),
        });
        if (!shared) {
            n8n_workflow_1.LoggerProxy.info('User attempted to update a workflow without permissions', {
                workflowId,
                userId: user.id,
            });
            throw new __1.ResponseHelper.ResponseError(`Workflow with ID "${workflowId}" could not be found to be updated.`, undefined, 404);
        }
        if (!forceSave && workflow.hash !== shared.workflow.hash) {
            throw new __1.ResponseHelper.ResponseError(`Workflow ID ${workflowId} cannot be saved because it was changed by another user.`, undefined, 400);
        }
        await __1.WorkflowHelpers.replaceInvalidCredentials(workflow);
        __1.WorkflowHelpers.addNodeIds(workflow);
        await Server_1.externalHooks.run('workflow.update', [workflow]);
        if (shared.workflow.active) {
            await __1.ActiveWorkflowRunner.getInstance().remove(workflowId);
        }
        if (workflow.settings) {
            if (workflow.settings.timezone === 'DEFAULT') {
                delete workflow.settings.timezone;
            }
            if (workflow.settings.saveDataErrorExecution === 'DEFAULT') {
                delete workflow.settings.saveDataErrorExecution;
            }
            if (workflow.settings.saveDataSuccessExecution === 'DEFAULT') {
                delete workflow.settings.saveDataSuccessExecution;
            }
            if (workflow.settings.saveManualExecutions === 'DEFAULT') {
                delete workflow.settings.saveManualExecutions;
            }
            if (parseInt(workflow.settings.executionTimeout, 10) ===
                config_1.default.get('executions.timeout')) {
                delete workflow.settings.executionTimeout;
            }
        }
        if (workflow.name) {
            workflow.updatedAt = new Date();
            await (0, GenericHelpers_1.validateEntity)(workflow);
        }
        const { hash, ...rest } = workflow;
        await __1.Db.collections.Workflow.update(workflowId, rest);
        if (tags && !config_1.default.getEnv('workflowTagsDisabled')) {
            const tablePrefix = config_1.default.getEnv('database.tablePrefix');
            await TagHelpers.removeRelations(workflowId, tablePrefix);
            if (tags.length) {
                await TagHelpers.createRelations(workflowId, tags, tablePrefix);
            }
        }
        const options = {
            relations: ['tags'],
        };
        if (config_1.default.getEnv('workflowTagsDisabled')) {
            delete options.relations;
        }
        const updatedWorkflow = await __1.Db.collections.Workflow.findOne(workflowId, options);
        if (updatedWorkflow === undefined) {
            throw new __1.ResponseHelper.ResponseError(`Workflow with ID "${workflowId}" could not be found to be updated.`, undefined, 400);
        }
        if (((_a = updatedWorkflow.tags) === null || _a === void 0 ? void 0 : _a.length) && (tags === null || tags === void 0 ? void 0 : tags.length)) {
            updatedWorkflow.tags = TagHelpers.sortByRequestOrder(updatedWorkflow.tags, {
                requestOrder: tags,
            });
        }
        await Server_1.externalHooks.run('workflow.afterUpdate', [updatedWorkflow]);
        void __1.InternalHooksManager.getInstance().onWorkflowSaved(user.id, updatedWorkflow, false);
        if (updatedWorkflow.active) {
            try {
                await Server_1.externalHooks.run('workflow.activate', [updatedWorkflow]);
                await __1.ActiveWorkflowRunner.getInstance().add(workflowId, shared.workflow.active ? 'update' : 'activate');
            }
            catch (error) {
                workflow.active = false;
                await __1.Db.collections.Workflow.update(workflowId, workflow);
                updatedWorkflow.active = false;
                throw error;
            }
        }
        return updatedWorkflow;
    }
}
exports.WorkflowsService = WorkflowsService;
//# sourceMappingURL=workflows.services.js.map